Self-host化によるSwiftコンパイラのソースコード可読性の向上

1. 序論 :introduction
    1. 背景 :background
        * Swiftがオープンソース化した
        * マルチプラットフォームへの展開
        * プログラムの拡張・修正が増える
        * 多くのプログラマが関わり、レビューの重要性が高まる
        * それらの効率を上げるために可読性は重要
        * 可読性をあげるための手段としてSelf-host化がある
        * 人気の高級汎用言語20件のうち7件がBootstrapしている
          (完全に置き換えるステップ全体を指してBootstrapと呼ぶ)
        * Swiftでは短期的にBootstrapを行うつもりはないとされている
    2. 本研究が着目する課題 :issue
        * 可読性に対する要求が高まっているという点に着目する
        * 現在は既存コードのコーディングスタイルへの追従とレビューで保たれている
        * 追加コードが多くなったりレビュアーが多様化すると維持できなくなる
    3. 本研究の目的とアプローチ :purpose
        * Swiftコンパイラの可読性を向上させることを目的とする
        * アプローチとして、他のコンパイラでよく行われているSelf-host化を用いる
    3. 本論文の構成
2. プロジェクトのオープンソース化が与える影響 :open-source<br>
   Swiftが行ったオープンソース化の一般的な特徴とそれに伴う変化について述べ、本研究で着目する課題を整理する
    1. オープンソースプロジェクトの特徴 :feature
        * オープンソースプロジェクトとは
            * Open Source Initiativeが定義を与えている(http://opensource.org/docs/osd)
                1. そのソフトウェア全体を含むソフトウェアの販売・頒布を使用料を課すなどして制限しない
                2. ソースコードを利用・改変しやすい形で使用料などを課さずに公開し、その再頒布を制限しない
                3. そのソフトウェアの改変・派生および改変・派生したものの同ライセンスでの頒布ができる
                4. ソースコードとパッチファイルを共に頒布でき、変更されたソフトウェアの頒布が明確に認められていれば、改変されたソースコードの頒布を制限してもよい
                5. 特定の個人や団体を差別しない
                6. 利用する分野を制限しない
                7. 再頒布されたものであっても、追加の規約などなしにそのプログラムに付随する権利が認められる
                8. そのプログラムのライセンスの範囲内で使用・頒布される場合は、プログラムの一部分だけであっても同じ権利が認められる
                9. そのソフトウェアと共に頒布されるソフトウェアに対する制限は行わない
                10. 特定の技術やインターフェース形式に限定した条件を課さない
            * オープンソースプロジェクトではその開発形式もオープンとなる
            * 定義の4番目に当てはまるようなものではない、多くのオープンソースプロジェクトで取られている流れ
                1. 任意のユーザからのソフトウェアの拡張や修正提案・要求
                    * オープンなチケット管理ツールやメーリングリストなどでの拡張・変更提案・バグ報告と議論
                2. 特定の開発者による拡張や修正の実装と提案
                    * パッチファイルの投稿
                    * PullRequestの作成
                3. 他の開発者による実装へのレビュー
                    * コーディングスタイルや機能の必要性に関する指摘や議論
                4. 修正・拡張の本体ソフトウェアへの統合
                    * 拡張・修正後のソフトウェアをプロジェクトの最新バージョンとして置き換え
        * プロジェクト形式の差異
            * 人気エッセイ http://www.catb.org/~esr/writings/cathedral-bazaar/ でオープンソースプロジェクトには「伽藍」と「バザール」という2つの形式があると述べられている
            * 伽藍形式の特徴
                * 中央集権的に開発方針などを指揮し、主な開発を担当する特定集団が存在する
                * 拡張や修正は開発方針に従って行われ、各リリースはよくチェックされる
            * バザール形式の特徴
                * 中心的な開発者が指揮者として与える影響は小さく、どの拡張や修正が実施されるかはコミュニティ全体の動向に左右される
                * リリースは変更が加わるごとに更新され、極端に言えばバグを含んだまま行われる
            * Swiftはバザール形式を目指していると見えるため、ここではバザール形式のオープンソースプロジェクトについて述べる
        * バザール形式のオープンソースプロジェクトにおける開発はそうでないプロジェクトにおける開発と異なる特徴を持つ
            1. 様々な人がプログラムを参照する
                * プログラムのあらゆる箇所に対して任意のタイミングで拡張提案・バグ報告が行われる
            2. 不特定多数のプログラマが開発に携わる
                * プログラムのあらゆる箇所に対して任意のタイミングで拡張・修正が行われる
                * 様々なコーディングスタイルの拡張・修正実装が提案される
            3. ソフトウェアを利用したソフトウェアが開発される
                * ソフトウェアの部分的な利用が試みられる
            4. ソフトウェアの技術中立性が高まる
                * 様々なプラットフォームへの移植が試みられる
    2. クローズドプロジェクトのオープンソース化による変化 :change
        * オープンソースプロジェクトには初めからオープンなものと初めはクローズドなものがあるが、ここでは後者について述べる
        * :open-source:featureで述べた特徴とクローズドプロジェクトの特徴を比較して変化をまとめる
        * バザール形式でオープンソース化すると、中央管理的に判断されていた事項が民主的に判断されるようになるという変化が最も大きい
            1. 拡張や修正の要求・実装が行われるかどうかを決定する要因の変化
                * クローズドなプロジェクトではリソースが限られているため、一定の開発方針に従って拡張や修正の優先順位が決定する
                * オープンなプロジェクトではある拡張や修正がそのコストを差し引いても充分な興味を引くものであれば、充分なリソースによって実装されて統合される
                * 逆に言えば、コストに見合うだけの充分な興味を惹けなければその拡張や修正は実装・統合されない
                * より多くの実装が行われるようにするためには、拡張・修正のコストを低くする必要がある
            2. コーディングスタイルの流動化
                * クローズドなプロジェクトでは開発者へのコーディングスタイルの徹底が可能なので同じスタイルを維持することができる
                * オープンなプロジェクトでは過去のコードとの統一性も踏まえられるものの、その時々で支持されたコーディングスタイルが用いられるため、スタイルが変動する
                * より進んだコーディングスタイルが用いられるようになる場合もあるが、コード全体におけるスタイルが統一されなくなる場合もある
            3. ソフトウェアの各部分におけるモジュール化
                * クローズドなプロジェクトではソフトウェアの利用先などをすべて把握することが可能なのでモジュール化する部分を限定できる
                * オープンなプロジェクトではあらゆる箇所で様々な形でソフトウェアが部分的にも使用されうるため、様々な箇所で高いモジュール性が求められる
                * プロジェクトの開発コミュニティがバザール形式の意図通りに機能していれば、ソフトウェアの各部分が独立し、モジュール化するようになる
            4. マルチプラットフォーム化の進行
                * 各プラットフォームの熱心なユーザにとってそのプラットフォームで対象ソフトウェアを使えるようにすることはそのソフトウェアを使用するための第一歩である
                * クローズドなプロジェクトでは対象とするプラットフォームを制限することが可能
                * オープンなプロジェクトでは各プラットフォームの熱心なユーザによってマルチプラットフォーム化が進められる
        * 特に1つ目の変化によって拡張・修正のコストがある機能を実装するか否かを判断する上で重要な変数となる点には注意しなければならない
        * より活発なオープンソースプロジェクトにするためには少しでも拡張・修正のコストを下げる必要がある
    3. 拡張・修正のコストと可読性 :readability
        * 拡張・修正のコストはソフトウェアの可読性によって決定する (elshoff)
        * 可読性は様々な要因によって決定するが、大きく分けて以下2つの側面によって決定する
            1. ソフトウェアの複雑性
            2. ソフトウェアの対象とする問題やソフトウェアに使用されている手法に対するプログラム読者の知識
        * ソフトウェアの複雑性が低かったり、拡張・修正を行う開発者の知識がそのソフトウェアと合致しているなら、拡張・修正を行う際の可読性は高くなる
        * そして、ソフトウェアの複雑性は3つの側面によって決定する (http://www3.nd.edu/~rsanteli/pate-sp12/readings/SurveyComplexity.pdf)
            1. ソフトウェアが対象とする問題
            2. 使用するプログラミング言語やモデリング手法、設計手法
            3. 参加する開発者
        * 1、2、3の順に複雑性に対して与える影響は小さい
    3. 本研究が着目する課題 :issue
        * 最近オープンソース化したプロジェクトにプログラミング言語Swiftがある
        * 近年のコンパイラでは対象とする問題(プログラムのコンパイル)が大きく難解であるため、それだけでも複雑性が高くなり、可読性が下がり、拡張・修正のコストが高くなっている
        * それにもかかわらず、Swiftではオープンソース化した後も可読性の維持・向上のための明確な施策を打っていない
        * 現在のソースコードの可読性は丁寧なコードレビューによってようやく保たれているが、これはレビュアーの多様化によって成り立たなくなったり、開発スピードのボトルネックとなり得る
        * オープンソースプロジェクトとなったSwiftでは今まで以上にそのソースコードの可読性を重視し、少しでも向上していく必要がある
        * 本研究ではこの課題に対して取り組む
3. ソースコード可読性の向上方法と評価手法 :readability
    1. 可読性を向上するためのアプローチ :approach
        * 可読性を向上するためには:open-source:readabilityで述べた可読性を決定する各要因の内のどれかを改善する必要がある
        * ただし、一般的にソースコードの可読性が問題になるようなフェーズではソフトウェアの対象とする問題は充分に明確化されているであろうことから、問題を変更するようなアプローチについては対象としない
            1. ソフトウェアの複雑性を下げる手法
                1. 使用するプログラミング言語を理解しやすいものにする
                    * より高級な言語を使用するようにするなど
                2. 使用するモデリング手法を理解しやすいものにする
                    * 問題の捉え方を変え、より単純なモデルへ落としこむようにするなど
                3. 使用する設計手法を理解しやすいものにする
                    * 使用するデータ構造やアルゴリズムをより単純なものにするなど
                4. 参加する開発者がより理解しやすいプログラムを書くようにする
                    * コーディング規約によってプログラムの書き方を制限する
                    * コメントやテストの記述量に対して制限を設けるなど
            2. 拡張・修正を行う開発者の知識を合致させる手法
                1. 拡張・修正を行う開発者がよりその対象とする問題についてよく知っているようにする
                    * 対象とする問題をより広く認知されている別の問題に置き換える
                    * 問題について整理したドキュメントを用意するなど
                2. 拡張・修正を行う開発者がよりソフトウェアで用いられている手法についてよく知っているようにする
                    * より広く知られたプログラミング言語や手法を採用する
                    * 手法について整理したドキュメントを用意するなど
                3. ソフトウェアで使用する手法を減らす
                    * 使用するプログラミング言語やモデリング手法、設計手法、ツールの種類を減らすなど
        * これらのアプローチのより具体的な方法や各方法の実現可能性は対象とする問題によって変化する
        * :open-source:readabilityで述べたように開発者よりもその手法の改善を行う方が複雑性を下げる効果は高い可能性が高い
    2. ソースコード可読性の評価手法 :evaluation
        * 拡張・修正を行う開発者の知識を合致させるような手法ではその具体的な方法に合わせて定性的な手法も含む評価手法を考える必要がある
        * あるいは、単に使用する手法の種類を減らす場合などは確かにその手法が使われておらず、新しい手法の導入などが行われていないことだけを確認すれば、必要な知識が減っていることは明らかである
        * ソフトウェアの複雑性についてはよく知られた3種類の古典的な手法がある (http://www3.nd.edu/~rsanteli/pate-sp12/readings/SurveyComplexity.pdf)
        * 各評価手法の概要とその特徴
            1. Line of Code (LOC)
                * ソフトウェアの実行可能なソースコードの行数とバグの密度の間にある相関関係から行数を指標にソフトウェアの複雑性を比較する
                * 各行の複雑性の差は無視している
                * プログラムの構造は一切勘案されない
                * 対象とするプログラムや開発者の技術などの要因によって最もバグ密度の低いソースコードの行数は変化する
            2. Halstead Complexity Metrics (HCM)
                * ソースコード中の演算子と被演算子の種類および数に基づく指標によってソフトウェアの複雑性を比較する
                * データフローに基づく複雑性のみで制御フローに基づく複雑性は勘案されないため、分岐が1つもないプログラムと無限の分岐が存在するプログラムでも指標は同じ値となりうる
            3. Cyclomatic Complexity Metric (CCM)
                * ソースコード中の線形独立な経路の数を指標としてソフトウェアの複雑性を比較する
                * 制御フローに基づく複雑性のみでデータフローに基づく複雑性は勘案されないため、経路の数が同じであれば1文だけのプログラムと無限の文を持つプログラムでも指標は同じ値となり得る
        * これらの手法は全てソースコードの可読性と経験則的に繋がりがあるというだけ
        * 各値を様々な角度から考察して初めて意味を成す
        * また、関連するデータの数やそのデータとのトランザクションの数を元にした指標としてファンクションポイント法があるが、これは:open-source:readabilityで述べた複雑性の側面の内対象とする問題と手法の一部分しか対象としない
    3. 本研究のアプローチ :idea
        * :open-source:issueで述べたとおり、Swiftコンパイラではその対象とする問題の大きさから既に可読性が他のソフトウェアと比較して低いと思われる
        * :open-source:changeで述べたようにバザール形式のオープンソースプロジェクトでは方針の民主的な決定が大きな違いを生む
        * 普段の開発の流れに対して大きく介入するようなアプローチではオープンソース化によるメリットを潰してしまう可能性がある
        * :readability:approachで述べたようなコーディング規約などによる制約を課すことは避けたい
        * また、開発者に対する改善よりも手法などに対する改善の方が効果が高いと期待できる
        * :introduction:backgroundで述べたように、他のコンパイラでよく行われている手法としてコンパイラを自分自身で書き直すSelf-host化がある
        * Self-host化を行えばコンパイラの記述言語に関する知識をコンパイル対象言語に関する知識と統一化できるため、ソフトウェアで使用する手法を減らすことになる
        * 一般に後発の言語のほうが高級であることが多いため、Swiftで記述されたコンパイラの方が現行のC++で書かれたものよりも優れた可読性を持っていると期待できる
        * Self-host化したSwiftコンパイラを実装し、:readability:evaluationで述べた古典的な3つの手法のどれかでそのコンパイラの複雑性を現行のコンパイラと比較することでアプローチの正当性を考察する
4. 提案手法において発生しうる副作用 :side-effect<br>
   本研究ではコンパイラの可読性を向上する目的でSelf-host化を用いるが、他の言語におけるコンパイラではさまざまな目的を持ってSelf-host化が行われている<br>
    1. Bootstrapの事例
        1. Go - go
        2. Python - PyPy
        3. C# - .NET Compiler Platform
    2. SwiftコンパイラにおけるSelf-host化の副作用
        * 性能が低下する可能性がある
5. Self-host化したSwiftコンパイラ「TreeSwift」の設計と実装 :implementation
    1. 可読性の比較が可能な箇所の絞り込み :comperable
        1. Swiftコンパイラの構造 :structure
            * Swiftコンパイラはおおまかに5つのステップに分けられる
                * 構文解析
                * 意味解析
                * SIL(Swift Intermediate Language)生成
                * 詳細解析
                * IR(LLVM-IR)生成
        2. 可読性の比較が可能な箇所 :part
            * :open-source:readabilityで述べたように、扱う問題や手法が異なるとそのプログラムの複雑性は大きく変化する
            * 参照解決や型推論、型検査を行う意味解析と最適化などを行う詳細解析は同じ問題を対象として同じ手段を取っているということを確認するのが難しい
            * Self-host化し、Swiftで記述した場合はLLVMのC++ APIを直接使用できないため、C APIを使用することとなる
            * IR生成部分は異なるAPIを使用することによる影響が大きく出ることが考えられる
            * そのため、:readability:evaluationで上げたような手法で比較できそうなのは構文解析部分とSIL生成部分
            * ただ、SIL生成部分はSILの仕様がまとまって公開される前だったため、設計に含めることが難しかった
            * そのため、本研究では構文解析部分のみを設計対象とする
    2. 一般的なコンパイラの構文解析器の構造 :parser<br>
       :implementation:comperable:partでも言及したとおり、同じ問題を対象と出来ているかどうか、同じ手法を用いているかは比較の上で重要な注意点
        1. 構文解析器の要素
            * 構文解析器は大きく分けて3つの機能からなる
                1. ソースファイルの文字列を意味のある文字単位(字句)に分ける字句解析
                2. 字句を意味のある文章単位ごとに処理してASTを組み上げる構文解析
                3. 構文の間違いを報告するエラー処理
        2. 構文解析器の扱う問題
            * 大きく分けて2つの問題を解決するために構文解析器は存在する
                1. 構文処理
                    * 正しい構文で記述されたソースコードを正しく解析すること
                2. エラー検知
                    * 間違った構文で記述されたソースコードの間違いを指摘すること
            * この2つの面の少なくとも大きな点については一致している状態で比較する必要がある
        3. 構文解析器の手法
            * エラー検知については構文解析器だけでなく、後の意味解析や詳細解析でも行うため、実装によってどの段階でどのエラーを検知するか、などは大きく異なる場合がある
            * 構文処理については文法に応じて3種類の手法がある (dragonbook)
                1. 汎用構文解析
                2. 下向き構文解析
                3. 上向き構文解析
    3. TreeSwiftの設計
        * 構文解析器のみに絞る
        * 構文処理は網羅された仕様書が作成できるので、実際に解析ができるかどうかを網羅的に調べることができるので、できるだけ現行のものと同じになるように実装する
        * エラー検知はどれだけ網羅できているかを判断しづらいため、比較の対象から外す
        * 同じ手法を徹底することは難しいが、構文解析器全体では同じLL(k)方式を用いる
    4. 実装の概要
        * 字句解析には各リテラルの解析を行う決定性有限オートマトンを複数用いている
        * モジュール定義にはテキストファイルを使用する
        * エラー回復は実装されていない
6. 評価 :evaluation
    1. ソースコード可読性の向上評価
        1. 評価手法
            * LOCをベースとする
            * エラー処理の違いが大きく出る可能性がある
                * 実行可能な行からさらに実行した行のみを取り出して比較する
                * 実行可能な行の内どれだけを対象にできているかを算出する
                * 分岐を決定する文を除いた場合の行数も算出する
            * モジュール定義ファイルのパースには大きな差がでる可能性がある
                * モジュールのパースやコンパイラオプションの処理などは対象に含めない
        2. 計測
        3. 考察
    2. Self-host化に伴う副作用の評価
        1. 評価手法
            * 速度とメモリ使用量を計測する
        2. 計測
        3. 考察
7. 結論
    1. 本研究の結論
        * すべての指標において可読性はSelf-host化したものが上回っていた
        * Self-host化によって可読性の向上が期待できる
        * この可読性の向上によって実際の作業量がどれほど変化するかは判らない
        * Halsteadの提唱する式では労力などに換算できるとされているが、批判的な意見が多い
        * Self-host化によって性能については低下する可能性がある
        * 本研究もSwiftがバザール形式のオープンソースとなったことによる成果の1つであり、実際にSelf-host化を進めるかどうかを判断するためにはもっと様々な角度から吟味される必要がある
    2. 今後の展望
        1. 構文解析器以外の比較
            * SIL解析は比較できる可能性がある
            * 意味解析や詳細解析についても機能の同じ部分だけを慎重に選べば比較できそう
        2. 継続的な比較
            * アップデートの多い新しい言語なので今後の変更で値が変化する可能性がある
            * ソフトウェア・メトリクスに対してはソフトウェア完成後の比較しかできない点が弱いとされている
            * 同じ機能部分だけを取り出して比較し続けることで修正・拡張による可読性の変化を見ることはできそう
            * 性能については常に変化するものなので、より継続的に見る意味がある
