\chapter{ソースコード可読性の向上方法と評価手法}
\label{readability}

本章では、本研究が目的とするソフトウェアのソースコード可読性の向上を達成するためのアプローチについて整理し、そのアプローチによって可読性が向上したかどうかを検証するための既存手法についてまとめる。

\section{可読性を向上するためのアプローチ}
\label{readability:approach}

~\ref{open-source:readability}節ではソフトウェアのソースコード可読性を向上するために表~\ref{table:readability-relation}に示した要因について適切な改善を行う必要があることと、その内の複雑性については表~\ref{table:complexity-elements}に示した要因に分解できることを説明した。
本説ではそのために考えられるアプローチについて整理するが、そのより具体的な手法が適用可能かどうかはアプローチを適用するソフトウェアの対象とする問題に依存するため、ここでは手法の例を挙げるに留める。

表~\ref{table:readability-approach}がその考えられるアプローチを列挙したものである。
なお、表~\ref{table:complexity-elements}でもソフトウェアが対象とする問題の変更などによる複雑性の解消が難しいことについては言及していたが、そもそも本研究で対象としているような拡張・修正が主体となるような開発フェーズではそのソフトウェアの対象とする問題は充分に明確化されている場合がほとんどであるため、問題を変更するようなアプローチについては取り上げていない。

~\ref{open-source:readability}節で述べたようにソフトウェアの複雑性についての改善を行う場合はアプローチする要因によって複雑性に対する影響が異なるため、表~\ref{table:readability-approach}に挙げたソフトウェアの複雑性に対するアプローチの中では上半分にあるものの方が下半分のものよりも結果的に可読性の向上に対してより高い効果を得られると期待できる。

\begin{table}[!hbtp]
    \begin{center}
        \caption{可読性を向上するためのアプローチ}
        \begin{listliketab}
        \begin{tabular}{|p{0.25\linewidth}|p{0.35\linewidth}|p{0.35\linewidth}|}
            \hline
            アプローチする可読性の要因 & アプローチ & 具体例 \\
            \hline
            \hline
            & 使用するプログラミング言語を理解しやすいものにする & \textbullet \ より高級な言語を使用するようにする \\
            \cline{2-3}
            & 使用するモデリング手法を理解しやすいものにする & \textbullet \ 問題の捉え方を変え、より単純なモデルへ落としこむようにする \\
            \cline{2-3}
            ソフトウェアの複雑性 & 使用する設計手法を理解しやすいものにする & \textbullet \ 使用するデータ構造やアルゴリズムをより単純なものにする \\
            \cline{2-3}
            & 参加する開発者がより理解しやすいプログラムを書くようにする & \textbullet \ コーディング規約によってプログラムの書き方を制限する \\
            & & \textbullet \ コメントやテストの記述量に対して制限を設ける \\
            \hline
            & 拡張・修正を行う開発者がよりその対象とする問題についてよく知っているようにする & \textbullet \ 対象とする問題をより広く認知されている別の問題に置き換える \\
            & & \textbullet \ 問題について整理したドキュメントを用意する \\
            \cline{2-3}
            拡張・修正を行う開発者の知識 & 拡張・修正を行う開発者がよりソフトウェアで用いられている手法についてよく知っているようにする & \textbullet \ より広く知られたプログラミング言語や手法を採用する \\
            & & \textbullet \ 手法について整理したドキュメントを用意する \\
            \cline{2-3}
            & ソフトウェアで使用する手法を減らす & \textbullet \ 使用するプログラミング言語やモデリング手法、設計手法、ツールの種類を減らす \\
            \hline
        \end{tabular}
        \label{table:readability-approach}
        \end{listliketab}
    \end{center}
\end{table}

\section{ソースコード可読性の評価手法}
\label{readability:evaluation}

~\ref{readability:approach}節で述べたような可読性を向上するためのアプローチを取ったとしても、それが必ずしも可読性の向上に繋がるとは限らないため、確かに可読性が向上したことを確認するための評価手法が必要となる。

表~\ref{table:readability-approach}に挙げた中でも下半分の拡張・修正を行う開発者の知識を合致させるようなアプローチでは、場合によっては定量的な数値に落としこむことが難しいため、その具体的な方法に合わせて定性的な手法も含む評価手法を考える必要がある。
それに対して、ソフトウェアの複雑性については定量的に評価するための手法が多く考案されている。
本節では、その中でも特によく取り上げられる4種類の手法について整理する ~\cite{yu} ~\cite{symons}。
なお、これら4つの手法は全て、その値が経験則的にソフトウェアの複雑性と結びついているとされているだけであるため、実際に使用する際にはその結果について慎重に考察する必要がある。

\subsubsection{LOC (Line of Code)}

LOCではソフトウェアの実行可能なソースコードの行数とバグの密度などとの間にある相関関係から行数を指標にソフトウェアの複雑性を算出する。

LOCは最も古典的でありながらもその扱いの容易さからよく用いられているが、特にプログラムの構造がその結果に一切反映されていないという点に注意する必要がある。

\subsubsection{FP (Function Point)}

FPは1979年にAllan J. Albrechtによって提案された。
ソフトウェアへ入出力されるデータとその入出力操作を列挙して重み付けを行い、その総和を指標にソフトウェアの複雑性を算出する。

FPは特に商用ソフトウェアの工数見積などの目的でよく使用されているが、算出ソフトウェア内のデータ処理による複雑性は経験則的に決定される重み付けのみによって反映される。

\subsubsection{HCM (Halstead Complexity Metrics)}

HCMは1977年にMaurice H. Halsteadによって提案された。
ソースコード中の演算子と被演算子の種類および数に基づく指標によってソフトウェアの複雑性を算出する。

HCMではデータフローに基づく複雑性を算出することができるとされているが、制御フローに基づく複雑性は一切勘案されていないため、分岐が1つもないプログラムと無限の分岐が存在するプログラムでも指標は同じ値となりうるなど注意が必要である。

\subsubsection{CCM (Cyclomatic Complexity Metric)}

CCMは1976年にThomas J. McCabeによって提案された。
ソースコード中の線形独立な経路の数を指標としてソフトウェアの複雑性を算出する。

CCMでは制御フローに基づく複雑性を算出することができるとされているが、データフローに基づく複雑性は一切勘案されないため、経路の数が同じであれば1文だけのプログラムと無限の文を持つプログラムでも指標は同じ値となりうるなど注意が必要である。

\section{本研究のアプローチ}
\label{readability:idea}

~\ref{open-source:change}節で述べたように、バザール形式のオープンソースプロジェクトでは方針の民主的な決定が他の形式のプロジェクトとの違いを生む主要因となっている。
そのため、その民主的な開発を促すために普段の開発の流れに対して大きく介入するようなアプローチをとってしまうと、オープンソース化によるメリットを潰してしまい、結果として逆効果となってしまう可能性すら考えられる。
その視点からすると、~\ref{readability:approach}節で例として述べたようなコーディング規約などによって制約を課すようなアプローチではその期待できる効果の薄さの割に逆効果となるリスクまで背負うこととなり、あまり良いアプローチであるとは考えられない。

そこで、本研究では~\ref{introduction:background}節でも他のコンパイラでよく用いられている手法として挙げたSelf-host化を可読性を向上するためのアプローチとして使用する。

Self-host化は表~\ref{table:complexity-elements}で示したソフトウェアの複雑性に影響する要因の内でも比較して大きな影響を持つ、使用するプログラミング言語の変更であるため、ソフトウェアの複雑性を大きく解消できる可能性がある。
さらに、Self-host化を行うと、コンパイラの記述言語とコンパイル対象言語が同じものになるため、コンパイラを記述している言語のために特別な知識を要さず、結果としてソフトウェアで使用する手法を減らすことができる。
これは表~\ref{table:readability-approach}で一番下に挙げているアプローチに他ならない。
つまり、Self-host化ではソフトウェアの複雑性とソフトウェア開発者に要求される知識の両面から可読性の向上に寄与すると期待できるのである。

ただし、~\ref{readability:evaluation}節で述べたとおり、実際にSelf-host化によってSwiftコンパイラの複雑性が解消されるかどうかを決定するには具体的にその複雑性の比較を行う必要がある。
特にSwiftコンパイラにおいては現行の実装が既に高級言語であるC++によって記述されているため、これをSwiftで書き直すことによって充分な可読性の向上を得られるかどうかをそれら言語の仕様など飲みから判断することは難しい。

そのため、本研究ではSelf-host化したSwiftコンパイラを実装し、~\ref{readability:evaluation}節で述べた手法のどれかを用いることでそのコンパイラの複雑性を現行のコンパイラと比較し、このアプローチの正当性を評価・考察する。

%%% Local Variables:
%%% mode: japanese-latex
%%% TeX-master: "../thesis"
%%% End:
