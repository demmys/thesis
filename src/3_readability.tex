\chapter{ソースコード可読性の向上方法と評価手法}
\label{readability}

本章では、本研究が目的とするソフトウェアのソースコード可読性の向上を達成するためのアプローチについて整理し、そのアプローチによって可読性が向上したかどうかを検証するための既存手法についてまとめる。

\section{可読性を向上するためのアプローチ}
\label{readability:approach}

* 可読性を向上するためには:open-source:readabilityで述べた可読性を決定する各要因の内のどれかを改善する必要がある
* ただし、一般的にソースコードの可読性が問題になるようなフェーズではソフトウェアの対象とする問題は充分に明確化されているであろうことから、問題を変更するようなアプローチについては対象としない
    1. ソフトウェアの複雑性を下げる手法
        1. 使用するプログラミング言語を理解しやすいものにする
            * より高級な言語を使用するようにするなど
        2. 使用するモデリング手法を理解しやすいものにする
            * 問題の捉え方を変え、より単純なモデルへ落としこむようにするなど
        3. 使用する設計手法を理解しやすいものにする
            * 使用するデータ構造やアルゴリズムをより単純なものにするなど
        4. 参加する開発者がより理解しやすいプログラムを書くようにする
            * コーディング規約によってプログラムの書き方を制限する
            * コメントやテストの記述量に対して制限を設けるなど
    2. 拡張・修正を行う開発者の知識を合致させる手法
        1. 拡張・修正を行う開発者がよりその対象とする問題についてよく知っているようにする
            * 対象とする問題をより広く認知されている別の問題に置き換える
            * 問題について整理したドキュメントを用意するなど
        2. 拡張・修正を行う開発者がよりソフトウェアで用いられている手法についてよく知っているようにする
            * より広く知られたプログラミング言語や手法を採用する
            * 手法について整理したドキュメントを用意するなど
        3. ソフトウェアで使用する手法を減らす
            * 使用するプログラミング言語やモデリング手法、設計手法、ツールの種類を減らすなど
* これらのアプローチのより具体的な方法や各方法の実現可能性は対象とする問題によって変化する
* :open-source:readabilityで述べたように開発者よりもその手法の改善を行う方が複雑性を下げる効果は高い可能性が高い

\section{ソースコード可読性の評価手法}
\label{readability:evaluation}

* 拡張・修正を行う開発者の知識を合致させるような手法ではその具体的な方法に合わせて定性的な手法も含む評価手法を考える必要がある
* あるいは、単に使用する手法の種類を減らす場合などは確かにその手法が使われておらず、新しい手法の導入などが行われていないことだけを確認すれば、必要な知識が減っていることは明らかである
* ソフトウェアの複雑性についてはよく知られた3種類の古典的な手法がある (http://www3.nd.edu/~rsanteli/pate-sp12/readings/SurveyComplexity.pdf)
* 各評価手法の概要とその特徴
    1. Line of Code (LOC)
        * ソフトウェアの実行可能なソースコードの行数とバグの密度の間にある相関関係から行数を指標にソフトウェアの複雑性を比較する
        * 各行の複雑性の差は無視している
        * プログラムの構造は一切勘案されない
        * 対象とするプログラムや開発者の技術などの要因によって最もバグ密度の低いソースコードの行数は変化する
    2. Halstead Complexity Metrics (HCM)
        * ソースコード中の演算子と被演算子の種類および数に基づく指標によってソフトウェアの複雑性を比較する
        * データフローに基づく複雑性のみで制御フローに基づく複雑性は勘案されないため、分岐が1つもないプログラムと無限の分岐が存在するプログラムでも指標は同じ値となりうる
    3. Cyclomatic Complexity Metric (CCM)
        * ソースコード中の線形独立な経路の数を指標としてソフトウェアの複雑性を比較する
        * 制御フローに基づく複雑性のみでデータフローに基づく複雑性は勘案されないため、経路の数が同じであれば1文だけのプログラムと無限の文を持つプログラムでも指標は同じ値となり得る
* これらの手法は全てソースコードの可読性と経験則的に繋がりがあるというだけ
* 各値を様々な角度から考察して初めて意味を成す
* また、関連するデータの数やそのデータとのトランザクションの数を元にした指標としてファンクションポイント法があるが、これは:open-source:readabilityで述べた複雑性の側面の内対象とする問題と手法の一部分しか対象としない

\section{本研究のアプローチ}
\label{readability:idea}

* :open-source:issueで述べたとおり、Swiftコンパイラではその対象とする問題の大きさから既に可読性が他のソフトウェアと比較して低いと思われる
* :open-source:changeで述べたようにバザール形式のオープンソースプロジェクトでは方針の民主的な決定が大きな違いを生む
* 普段の開発の流れに対して大きく介入するようなアプローチではオープンソース化によるメリットを潰してしまう可能性がある
* :readability:approachで述べたようなコーディング規約などによる制約を課すことは避けたい
* また、開発者に対する改善よりも手法などに対する改善の方が効果が高いと期待できる
* :introduction:backgroundで述べたように、他のコンパイラでよく行われている手法としてコンパイラを自分自身で書き直すSelf-host化がある
* Self-host化を行えばコンパイラの記述言語に関する知識をコンパイル対象言語に関する知識と統一化できるため、ソフトウェアで使用する手法を減らすことになる
* 一般に後発の言語のほうが高級であることが多いため、Swiftで記述されたコンパイラの方が現行のC++で書かれたものよりも優れた可読性を持っていると期待できる
* Self-host化したSwiftコンパイラを実装し、:readability:evaluationで述べた古典的な3つの手法のどれかでそのコンパイラの複雑性を現行のコンパイラと比較することでアプローチの正当性を考察する

%%% Local Variables:
%%% mode: japanese-latex
%%% TeX-master: "../thesis"
%%% End:
