\chapter{プログラミング言語Swift}
\label{explain-swift}

本章では、本研究の対象であるプログラミング言語Swiftの言語的特徴とSwiftコンパイラの構成について述べる。

\section{Swiftの特徴}

Swiftは他の言語と比較しても多くの特徴を備えており、それがそのコンパイラの複雑性を増しているために、Bootstrapにおける費用対効果の試算を困難にする原因となっている。

\subsection{マルチパラダイム}

プログラミング言語が採用するプログラミングパラダイムによって、その言語のコンパイラの設計、特に構文解析器とコード生成部分の設計は大きな影響を受ける。
Swiftは近年の汎用言語に採用されている多くのプログラミングパラダイムを取り入れているマルチパラダイムプログラミング言語であるため、以下ではSwiftで採用されている各プログラミングパラダイムについて概説する。

\subsubsection{関数型プログラミング}

Swiftでは関数を第一級のオブジェクトとして扱い、2つの型から成る関数型を用意することで、MLやHaskellなどの言語と同様のラムダ計算に近しい表記方法を行う関数型プログラミングが可能となっている。

Swiftにおける関数型プログラミングの例を~\ref{functional}に挙げる。
関数用の型が矢印演算子によって提供されており、関数自体を変数に代入して使用できていることがわかるだろう。

\begin{lstlisting}[caption=Swiftにおける関数型プログラミングの例, label=functional]
let f: Int -> Int = { x in x + 1 }
print(f(1)) // 標準出力に 2 と表示する
\end{lstlisting}

このパラダイムにより、コンパイラではCやJava、C++と比較して関数のために無名関数や部分適用といったより多くの構文を用意し、一般的に関数を第一級オブジェクトとして扱わない事が多いアセンブリ言語へは関数ポインタなどを使用することでそれらの構文を翻訳する必要がある。

\subsubsection{オブジェクト指向プログラミング}

Swiftが提供する複合型であるクラス、構造体、列挙体、プロトコルでは継承関係を定義することができ、外部の手続きから呼び出し可能な値や他の型定義などのメンバを持つことができるように設計されていることで、オブジェクト指向プログラミングを可能としている。

Swiftにおけるオブジェクト指向プログラミングの例を~\ref{objective}に挙げる。
この例では継承関係のあるクラスから生成されたオブジェクトに対し、クラスで定義された関数のメンバを呼び出している。

\begin{lstlisting}[caption=Swiftにおけるオブジェクト指向プログラミングの例, label=objective]
class Parent {
    func f() { print("parent") }
}

class Child : Parent {
    override func f() { print("child") }
}

let x: Parent = Child()
x.f() // 標準出力に child と表示する
\end{lstlisting}

このパラダイムを実現するために、コンパイラでは各複合型ごとのスコープの管理が必要になり、継承関係のある型同士を部分型として扱った上で、仮想関数テーブルなどを用いて実行時に呼び出すメンバを動的に決定できる仕組みを生成する必要がある。

\subsubsection{パターンマッチ}

Swiftは特定の構造を持つ値についてその一般的なパターンを定義し、変数を含む左辺値と変数を含まない右辺値を比較することで左辺値中の変数の型と値を決定するパターンマッチの機構を持っている。

Swiftにおけるパターンマッチの例を~\ref{pattern-match}に挙げる。
現在のSwiftではこの例のように列挙体の値について柔軟なパターンマッチを提供している。

\begin{lstlisting}[caption=Swiftにおけるパターンマッチの例, label=pattern-match]
enum Sample {
    case X, Y(Int)
}
let x = Sample.Y(1)

if case Sample.Y(let v) = x { // パターンマッチを行っている式
    print(v) // 標準出力に 1 と表示する
}
\end{lstlisting}

このパラダイムの実現には、コンパイラで左辺値のパターンが表す構造と型を解釈し、右辺値の値をより詳細な構造に分解してより単純な同値性を確認する演算や変数の宣言の集まりに変換する必要がある。


\subsection{強力な型システム}



\subsection{高い可読性}

\section{Swiftコンパイラの構成}
\label{explain-swift:structure}

\section{Swiftコンパイラの基幹的機能}

\section{Swiftコンパイラの課題}

%%% Local Variables:
%%% mode: japanese-latex
%%% TeX-master: "../thesis"
%%% End:
