\chapter{プログラミング言語Swift}
\label{explain-swift}

本章では、本研究の対象であるプログラミング言語Swiftの言語的特徴とSwiftコンパイラの構成について述べる。

\section{Swiftの特徴}

Swiftは他の言語と比較しても多くの特徴を備えており、それがそのコンパイラの複雑性を増しているために、Bootstrapにおける費用対効果の試算を困難にする原因となっている。

\subsection{マルチパラダイム}

プログラミング言語が採用するプログラミングパラダイムによって、その言語のコンパイラの設計、特に構文解析器とコード生成部分の設計は大きな影響を受ける。
Swiftは近年の汎用言語に採用されている多くのプログラミングパラダイムを取り入れているマルチパラダイムプログラミング言語であるため、以下ではSwiftで採用されている各プログラミングパラダイムについて概説する。

\subsubsection{関数型プログラミング}

Swiftでは関数を第一級のオブジェクトとして扱い、2つの型から成る関数型を用意することで、MLやHaskellなどの言語と同様のラムダ計算に近しい表記方法を行う関数型プログラミングが可能となっている。

Swiftにおける関数型プログラミングの例をソースコード~\ref{functional}に挙げる。
関数用の型が矢印演算子によって提供されており、関数自体を変数に代入して使用できていることがわかるだろう。

\begin{lstlisting}[caption=Swiftにおける関数型プログラミングの例, label=functional]
let f: Int -> Int = { x in x + 1 }
print(f(1)) // 標準出力に 2 と表示する
\end{lstlisting}

このパラダイムにより、コンパイラではCやJava、C++と比較して関数のために無名関数や部分適用といったより多くの構文を用意し、一般的に関数を第一級オブジェクトとして扱わない事が多いアセンブリ言語へは関数ポインタなどを使用することでそれらの構文を翻訳する必要がある。

\subsubsection{オブジェクト指向プログラミング}

Swiftが提供する複合型であるクラス、構造体、列挙体、プロトコルでは継承関係を定義することができ、外部の手続きから呼び出し可能な値や他の型定義などのメンバを持つことができるように設計されていることで、オブジェクト指向プログラミングを可能としている。

Swiftにおけるオブジェクト指向プログラミングの例をソースコード~\ref{objective}に挙げる。
この例では継承関係のあるクラスから生成されたオブジェクトに対し、クラスで定義された関数のメンバを呼び出している。

\begin{lstlisting}[caption=Swiftにおけるオブジェクト指向プログラミングの例, label=objective]
class Parent {
    func f() { print("parent") }
}

class Child : Parent {
    override func f() { print("child") }
}

let x: Parent = Child()
x.f() // 標準出力に child と表示する
\end{lstlisting}

このパラダイムを実現するために、コンパイラでは各複合型ごとのスコープの管理が必要になり、継承関係のある型同士を部分型として扱った上で、仮想関数テーブルなどを用いて実行時に呼び出すメンバを動的に決定できる仕組みを生成する必要がある。

\subsubsection{パターンマッチ}

Swiftは特定の構造を持つ値についてその一般的なパターンを定義し、変数を含む左辺値と変数を含まない右辺値を比較することで左辺値中の変数の型と値を決定するパターンマッチの機構を持っている。

Swiftにおけるパターンマッチの例をソースコード~\ref{pattern-match}に挙げる。
現在のSwiftではこの例のように列挙体の値について柔軟なパターンマッチを提供している。

\begin{lstlisting}[caption=Swiftにおけるパターンマッチの例, label=pattern-match]
enum Sample {
    case X, Y(Int)
}
let x = Sample.Y(1)

if case Sample.Y(let v) = x { // パターンマッチを行っている式
    print(v) // 標準出力に 1 と表示する
}
\end{lstlisting}

このパラダイムの実現には、コンパイラで左辺値のパターンが表す構造と型を解釈し、右辺値の値をより詳細な構造に分解してより単純な同値性を確認する演算や変数の宣言の集まりに変換する必要がある。


\subsection{強力な型システム}

強力な型システムはプログラマのミスを発見する有効な手立てとなり得るが、一般的にコンパイラの型推論や型検査にかかる時間との間でトレードオフの関係となる。
以下ではSwiftで採用されている型システムの特徴について述べる。

\subsubsection{型パラメータ多相}

Swiftでは各複合型や関数内で用いられている型を全称型を持つ変数で記述することにより、複数の型を対象とした複合型や関数を記述できる型パラメータ多相を採用している。

コンパイラでは全称型を持つ複合型や関数をその文脈によって決定された型で具体的に定義しなおし、それらの具体的に定義された型を同一の型として扱う必要がある。
この機能の実装は後述する型推論において型の解決が可能かどうかを決定するためのステップを大幅に増加させてしまうため、コンパイル時間との兼ね合いを考えてより絞り込んだ制約を要求するなど、状況に合わせたサポート機能を組み込む必要もある。

\subsubsection{関数のオーバーロード}

Swiftは意味的に同様の働きをするが異なる型を持つ引数を取る関数を同じ名前で扱える関数のオーバーロード機能を有している。

この機能によってコンパイラでは関数を単に他の値と同一に扱えず、どの関数が呼びだされているかを決定するためにはまず型を決定することが必要となる。

\subsubsection{型推論}

Swiftでは関数型プログラミングを可能とする多くの言語と同様にHindlyとMilnerによるアルゴリズムを採用した強力な型推論を備えている。

HindlyとMilnerによるアルゴリズムはMLやHaskellなど多くの関数型プログラミングを採用する言語で採用されているが、前述のとおりオブジェクト指向や型パラメータ多相、関数のオーバーロードを許すという特徴から、Swiftコンパイラではそれを大きく拡張した形で実装しなくてはならない。


\subsection{高い可読性}

Swiftがマルチパラダイム性と強力な型システムの他にその言語の特徴として大きく掲げているのが、高い可読性である。
Swiftでは未定義値を安全に取り扱うためのオプショナル型や無名関数を定義するためのクロージャ、複数の値をまとめて扱えるタプル、自由なデータ構造を記述可能な列挙体などについてその可読性を高めるための糖衣構文を用意している。

また、糖衣構文などを提供するために構文の曖昧性を残しているのもSwiftの特徴である。
例えば、ソースコード~\ref{ambiguous}のような構文はSwiftの構文定義に則った全く正しいコードだが、一般的なアプローチでは正しく解析することができない。
xの後に続くブレースがxの引数のクロージャの始まりなのか、if文の本体の始まりなのかはxが引数としてクロージャを取る関数であることを解析機が知っていなくてはならず、そのxは場合によってはこれから解析を行う他のファイルなどに宣言されている可能性があるからである。

\begin{lstlisting}[caption=曖昧な構文を持った正しいSwiftコード, label=ambiguous]
let x: (Bool -> Bool) -> Bool = { f in f(true) }

if x { b in b } { print("true") }
\end{lstlisting}

こうした構文を一切の曖昧性なしに解析するためにはコンパイル対象となるソースコードを参照の解決に必要な回数だけ走査しなくてはならなくなるが、それは少なく見積もっても大変非効率であり、現実的ではない。


\section{Swiftコンパイラの構成}
\label{explain-swift:structure}

\subsection{Swiftコンパイラのおおまかな構成}

\subsection{Swiftコンパイラの構文解析器}

%%% Local Variables:
%%% mode: japanese-latex
%%% TeX-master: "../thesis"
%%% End:
