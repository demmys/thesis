\chapter{Swiftコンパイラ中の可読性の比較が可能な箇所の絞り込み}
\label{refinement}

コンパイラは~\ref{side-effect:instance}節で見た事例だけからでも分かるように、同じプログラミング言語を対象としたものでもその設計手法やそもそも重視する問題が異なる場合がある。
かつ、~\ref{open-source:readability}節で挙げたように、ソフトウェアが対象とする問題やソフトウェアに使用される基幹的な手法はそのソフトウェアの複雑性を決定する上で大きな役割を演じる重要な変数となっている。
そのため、~\ref{readability:evaluation}節で述べたような手法を用いて実装を比較評価して得る複雑性の変化が確かにSelf-host化によって起こったものであると考えるためには、少なくとも対象とする問題と使用するプログラミング言語以外の基幹的な設計手法においては一致している必要がある。

そこで本説では、Swiftコンパイラの構造からどの部分について複雑性の比較が可能かを明らかにし、可読性の比較評価のために必要なTreeSwiftの設計要件を決定する土台を構築する。

\section{Swiftコンパイラの構造}
\label{refinement:structure}

Swiftコンパイラの大まかな構成を図~\ref{img:swift-compiler-process}に示した。
この図はSwiftの中心的開発者であるGroffとLattnerによるSwiftコンパイラについての説明資料~\cite{sil}中の図を訳し簡略化したものである。
Swiftコンパイラは図中矩形で表されている5つの処理によって図中円形で表されている4つのデータ形式を順に読み込み・生成する。
データ形式から処理を貫いて他のデータ形式まで伸びる矢線はデータ形式がどの処理によってどの順に生成されるかを表している。

\begin{figure}
    \begin{center}
        \includegraphics[scale=0.5]{./img/swift_compiler_process.png}
        \caption{Swiftコンパイラの構成}
        \label{img:swift-compiler-process}
    \end{center}
\end{figure}

この図が明らかにしているのは、Swiftコンパイラのデータ構造を媒介とした各処理ステップの独立性である。
Swiftコンパイラでは各処理ステップで扱うデータ形式を原則としてSwift、AST、SIL、LLVM-IRのいずれかに限定することで処理ステップ間の結合を疎にしている。

以下ではSwiftコンパイラで行われる各処理ステップについて、それぞれの目的とそのために使用されている手法について概説する。
なお、本論文内のSwiftコンパイラについての説明はswift-2.2-SNAPSHOT-2015-12-31-aのリリースにおけるソフトウェアの内容に基づいている。

\subsection{構文解析}

構文解析は次の2つの目的のために行われる。

\begin{enumerate}
    \item ただの文字列であるSwiftプログラムを解析して構造を持った抽象構文木(AST)に変換する
    \item プログラムの構文的な誤りを検知して報告する
\end{enumerate}

1つ目の目的を達成するために、SwiftではLL(k)クラスの再帰下降構文解析を用いている。
この手法についての理解を深めるために、以下では近代的なプログラミング言語に用いられるもう1つの構文解析手法と共にこの構文解析手法について解説する ~\cite{dragonbook}。

\subsubsection{下向き構文解析}

下向き構文解析では、プログラム全体を表現する非終端記号の文法から順により詳細な構成要素に深さ優先で分解していくことによってプログラムを解析する。
Swiftで用いられているLL(k)クラスの再帰下降構文解析は下向き構文解析の1種である。

% TODO dragonbook P.234のような図を追加

再帰下降構文解析は関数によって表現された手続きの集合として構成され、最初の文法を表現する手続きからより詳細な構成要素のための文法を表現する手続きを再帰的に呼び出すことで処理が行われる。
そのため、再帰下降構文解析では文法と実装が明確な対応関係を持っている事が多く、手作業で構文解析器を作成することが比較的簡単である。

\subsubsection{上向き構文解析}

上向き構文解析では、プログラムの字句を先頭から順に読み、具体的な字句をより抽象的な非終端記号へと還元していくことで当てはまる文法を決定していくことでプログラムを解析する。

% TODO dragonbook P.252のような図を追加

上向き構文解析において最もよく用いられているのはLR(1)クラスの構文解析器である。
LR(1)クラスの解析器は多くのプログラミング言語で用いられる文法の殆どを解析できる上、Yaccに代表されるような古くからよく用いられている構文解析器の自動生成するソフトウェアが存在する。

ただし、逆にLR(1)クラスの解析器を手作業で記述するのは容易ではない。

なお、LL(k)クラスの解析器についても構文解析器を自動生成するソフトウェアは存在するが、LR(1)クラスの解析器ほど頻繁に使用されてはいない ~\cite{antlr}。

\vspace{2em}

このように構文解析器には複数の設計手法が存在しており、その内の幾つかの手法においては同等の解析能力を保持しているため、どの手法を使用するかはプログラミング言語の仕様のみによっては決定しない。

また、構文解析器の2つ目の目的であるエラー検知については、その構文解析器が自動生成されるような場合には自動生成されたプログラムの用意するインターフェースによって検知タイミングや検知の難易度が変化する場合がある。

\subsection{意味解析}

目的
* AST中の変数や関数、型を互いに結びつけ、プログラム全体の整合性を確認する
* 開発者によって省略されている情報を補足する

手段
* 参照解決
* 型推論
* 型検査

分岐点
* 参照解決は構文解析中に行うものと終了後に行うものとがある
* 型推論にはC++的な手法とHindly-Milnerの手法がある
* 型検査は型の統一化によって別個に行われるか、Hindly-Milnerの手法でまとめて行われる

意味解析では主にプログラム中で使用されている変数や関数、型などを定義箇所と結びつける参照解決、型の明示されていない項に型付けを行う型推論、型付けが正しいことを検証する型検査を行う。

\subsection{SIL生成}

目的
* ASTを分析してより抽象度の低いSILに変換することで最適化などを行うための準備を行う

手段
* 特に一般的な手法などは用いられておらず、ASTとSILの設計に依存

分岐点
* ASTがどのような形で実装されるかはコンパイラを記述する言語の影響を受ける % TODO
* SILの設計は明確に共有されていない % TODO

SIL生成ではSwift独自の中間言語であるSwift Intermediate Language(SIL)をASTから生成する。
Swift Intermediate LanguageはLLVM-IRをベースとしてループやエラー処理、オブジェクト指向プログラミングのためのクラスの概念などを拡張し、プログラムの意味に基づく詳細なエラー検出などを行い易くした言語である ~\cite{sil}。

\subsection{詳細解析}

目的
* 抽象度が高すぎる状態(AST)や低すぎる状態(SIL)では処理しづらいエラーを検出する
* 同様の最適化を行う

手段
* コールグラフやクラス階層に基づく最適化手法など

分岐点
* ここで行われる最適化やエラー検知は必ずしもこのステップで行わなければいけないものではないことが多いため、どれをどのタイミングで行うかについて仕様などによる強制力はない
* SIL生成と同じくSILの設計に依存する

詳細解析ではSILから関数のコールグラフやクラス階層などの情報を抽出し、プログラム中の複数の文の相互作用によって発生するエラーの検出や判断に抽象レベルの高い情報を要する最適化などを行う。
また、Swiftではメモリ管理の手法として各オブジェクトの作成が要求された際に自動的にメモリを割り当て、不要になったタイミングを検知してメモリを開放するAutomatic Reference Counting方式を用いている~\cite{arc}が、そのための処理の挿入などもこの詳細解析で行っている。

\subsection{IR生成}

目的
* SILを分析してLLVM-IRを生成することで、低抽象度での最適化や機械語生成を行うための準備を行う

手段
* LLVM APIの使用

分岐点
* LLVM APIは使用できる言語が限られている
* もちろんLLVMを使用しなければこのステップは全く存在しない

IR生成ではSwiftがバックエンドに使用しているLLVMへ処理を渡すために、SILを解析してLLVM-IR(IR)を生成する。
LLVMは統一された中間言語であるLLVM-IRに対する最適化やLLVM-IRから様々なプラットフォーム上で動作可能な機械語へのコンパイルを行うツール群である ~\cite{llvm}。
LLVMのツールセットは実行可能なソフトウェアやC++向けに用意されたAPIを通して使用されている。
そのため、C++で記述されたSwiftコンパイラの本体ではライブラリのリンクやごく一般的な最適化、機械語の生成などは行っていない。

\section{可読性の比較が可能な箇所}
\label{refinement:comperable}

SwiftコンパイラはLLVMのような外部のツールを用いたり、SILのような独自言語を使用したりしているため、それらがTreeSwiftでもまったく同じように使用できるとは限らず、コンパイラ全体を比較対象とした場合は充分に同じ問題を同じ手法によって実装したものが比較できているとは言えなくなる可能性が高い。
しかし幸いなことに、~\ref{refinement:structure}節で述べたように、Swiftコンパイラは各処理ステップごとに扱う問題とそこで使用されている手法が明確に分離されている。
そこで本節では、各処理ステップごとにTreeSwiftでも同じ問題と設計手法を用いることが可能かどうかを考察することによって可読性の比較箇所を絞り込み、有意義な比較評価を行うための下準備を行う。

* :open-source:readabilityで述べたように、扱う問題や手法が異なるとそのプログラムの複雑性は大きく変化する
* 参照解決や型推論、型検査を行う意味解析と最適化などを行う詳細解析は同じ問題を対象として同じ手段を取っているということを確認するのが難しい
* Self-host化し、Swiftで記述した場合はLLVMのC++ APIを直接使用できないため、C APIを使用することとなる
* IR生成部分は異なるAPIを使用することによる影響が大きく出ることが考えられる
* そのため、:readability:evaluationで上げたような手法で比較できそうなのは構文解析部分とSIL生成部分
* ただ、SIL生成部分はSILの仕様がまとまって公開される前だったため、設計に含めることが難しかった
* そのため、本研究では構文解析部分のみを設計対象とする
