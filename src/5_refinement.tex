\chapter{Swiftコンパイラの構成と各部分における複雑性の比較難易度}
\label{refinement}

コンパイラは~\ref{side-effect:instance}節で見た事例だけからでも分かるように、同じプログラミング言語を対象としたものでもその設計手法やそもそも重視する問題が異なる場合がある。
かつ、~\ref{open-source:readability}節で挙げたように、ソフトウェアが対象とする問題やソフトウェアに使用される基幹的な手法はそのソフトウェアの複雑性を決定する上で重要な変数となっている。
そのため、~\ref{readability:evaluation}節で述べたような手法を用いて複雑性を計測・比較して得た変化が確かにSelf-host化によるものであると考えるためには、対象とする問題と提案手法以外の基幹的な設計手法が比較対象において同一である必要がある。
また、複雑性の比較を行う際にはどの手法を用いるにしても、巨大なソフトウェアであるコンパイラの全体について一度に比較してしまうと、各部分における複雑性の差が打ち消し合い、Self-host化が与えている要因に対する考察を行う上で評価の結果が扱いづらくなってしまうことが考えられる。

そこで本章では、現行のSwiftコンパイラをその機能によっていくつかの部分に切り分けた上で、各部分における目的と使用されている手法についてまとめ、その部分をSelf-host化した場合でも同じ目的のもとに同様の手法を取ることが可能かどうか考察することで、実際に本研究で実装を行って比較を行う部分を選択するための判断材料をつくる。

\section{Swiftコンパイラの構成}
\label{refinement:structure}

Swiftコンパイラの大まかな構成を図~\ref{img:swift-compiler-process}に示した。
この図はSwiftの中心的開発者であるGroffとLattnerによるSwiftコンパイラについての説明資料~\cite{sil}中の図を訳し簡略化したものである。
Swiftコンパイラは図中矩形で表されている5つの処理によって図中円形で表されている4つのデータ形式を順に読み込み・生成する。
データ形式から処理を貫いて他のデータ形式まで伸びる矢線はデータ形式がどの処理によってどの順に生成されるかを表している。

\begin{figure}
    \begin{center}
        \includegraphics[scale=0.5]{./img/swift_compiler_process.png}
        \caption{Swiftコンパイラの構成}
        \label{img:swift-compiler-process}
    \end{center}
\end{figure}

この図が表現しているのは、Swiftコンパイラのデータ構造を媒介とした各処理ステップの独立性である。
Swiftコンパイラでは各処理ステップで扱うデータ形式を原則としてSwift、AST、SIL、LLVM-IRのいずれかに限定することで処理ステップ間の結合を疎にしている。

以下ではSwiftコンパイラで行われる各処理ステップについて、それぞれの目的とそのために使用されている手法について概説する。
なお、本論文内のSwiftコンパイラについての説明はswift-2.2-SNAPSHOT-2015-12-31-aのリリースにおけるソフトウェアの内容に基づいている。

\subsection{構文解析}
\label{refinement:structure:parser}

構文解析は次の2つの目的のために行われる。

\begin{enumerate}
    \item ただの文字列であるSwiftプログラムを解析して構造を持った抽象構文木(AST)に変換する
    \item プログラムの構文的な誤りを検知して報告する
\end{enumerate}

1つ目の目的を達成するために、SwiftではLL(k)クラスの再帰下降構文解析を手作業で構築して用いている。
この手法についての理解を深めるために、以下では近代的なプログラミング言語に用いられるもう1つの構文解析手法と共にこの構文解析手法について解説する ~\cite{dragonbook}。

\subsubsection{下向き構文解析}

下向き構文解析では、プログラム全体を表現する非終端記号の文法から順により詳細な構成要素に深さ優先で分解していくことによってプログラムを解析する。
Swiftで用いられているLL(k)クラスの再帰下降構文解析は下向き構文解析の1種である。

\vspace{2em}
{\sl\small{TODO: dragonbook P.234のような図を追加}}
\vspace{2em}

再帰下降構文解析は関数によって表現された手続きの集合として構成され、最初の文法を表現する手続きからより詳細な構成要素のための文法を表現する手続きを再帰的に呼び出すことで処理が行われる。
そのため、再帰下降構文解析では文法と実装が明確な対応関係を持っている事が多く、手作業で構文解析器を作成することが比較的簡単である。

\subsubsection{上向き構文解析}

上向き構文解析では、プログラムの字句を先頭から順に読み、具体的な字句をより抽象的な非終端記号へと還元していくことで当てはまる文法を決定していくことでプログラムを解析する。

\vspace{2em}
{\sl\small{TODO: dragonbook P.252のような図を追加}}
\vspace{2em}

上向き構文解析において最もよく用いられているのはLR(1)クラスの構文解析器である。
LR(1)クラスの解析器は多くのプログラミング言語で用いられる文法の殆どを解析できる上、Yaccに代表されるような古くからよく用いられている構文解析器の自動生成ソフトウェアが存在する。
ただし、逆にLR(1)クラスの解析器を手作業で記述するのは容易ではない。
なお、LL(k)クラスの解析器についても構文解析器を自動生成するソフトウェアは存在する~\cite{antlr}が、LR(1)クラスの解析器ほど頻繁に使用されてはいない。

\vspace{2em}

このように構文解析器には複数の設計手法が存在しており、その内の幾つかの手法においては同等の解析能力を保持しているが、どの手法を採用するかによって構文解析器のプログラムは大きく変化する。
また、構文解析器の2つ目の目的であるエラー検知については、その構文解析器が自動生成されるような場合には自動生成されたプログラムの用意するインターフェースによって検知タイミングや検知の難易度が変化する場合がある。
そのため、構文解析器について複雑性を比較する場合には、少なくとも比較を行うコンパイラについても現行のSwiftコンパイラと同じようにLL(k)クラスの再帰下降構文解析を手作業で構築して利用されている必要があると考えられる。

これに加えて、SwiftではSwiftで作成されたライブラリを読み込むためにCやC++におけるヘッダファイルと同じような役割を担う独自形式のモジュールファイルをライブラリ作成時に自動生成しており、構文解析器はこれを解析する役割も担っている。
モジュールファイルの解析は通常のプログラムの解析とは別の関数をエントリ・ポイントとして実行されるために分離して考えることも可能だが、モジュールファイルの解析についても比較を行う場合は、解析にかかる作業量が大きく異なることを避けるために、同様の形式のモジュールファイルを使用している必要があると考えられる。

\subsection{意味解析}
\label{refinement:structure:sema}

意味解析の目的は次のとおりである。

\begin{enumerate}
    \item AST中の変数や関数、型を互いに結びつけ、プログラム全体の整合性を確認する
    \item 開発者によって省略されている情報を補足する
\end{enumerate}

1つ目の目的は主に参照解決と型検査、2つ目の目的は主に型推論を行うことによって達成される。
以下では意味解析の中で行われるこれら3つの処理についてSwiftで使用されている手法と複雑性の比較を行うために統一されるべき設計手法について述べる。

\subsubsection{参照解決}

プログラム中で使用される変数や関数が正確にどこで宣言された変数や関数を指しているかを知ることができるタイミングはその変数や関数がどんな種類であるかに依存する。

例えば、プログラム~\ref{code:explicit-reference}のようなSwiftプログラムでは2行目で参照される変数xが直前の行で宣言されているため、構文解析を行いながら宣言された変数の情報を蓄積しておけば、最短で2行目のxを読んだ直後に変数xの参照を解決できる。
それに対してプログラム~\ref{code:implicit-reference}のように少し複雑化すると、例えばプログラム中5行目の変数s.xの参照を解決するためにはいくつかのステップを踏む必要が出てくる。
このプログラムで変数s.xの参照を解決するためには、まず変数sの参照を解決し、その型が明示されていないためにこれを推論し、クラスSampleのメンバリストから変数xの宣言を探し出すという長大なステップを踏まなければならない。

\begin{lstlisting}[caption=直ちに変数解決が可能である例, label=code:explicit-reference]
let x: Int = 1
print(x)
\end{lstlisting}

\begin{lstlisting}[caption=変数解決までに複数の処理が必要となる例, label=code:implicit-reference]
class Sample {
    let x: Int = 1
}
let s = Sample()
print(s.x)
\end{lstlisting}

このように、参照解決のタイミングはプログラミング言語の仕様によって制限されるが、特に最短のタイミングで解決を行わないといけないということもないため、実装時の簡潔性などを勘案した上で各実装ごとに決定される。
実際、現行のSwiftコンパイラでも参照解決のタイミングはその変数や関数の参照のされ方によってまちまちである。

そのため、比較対象のコンパイラにおいても全く同じタイミングで同じように参照解決が行われるように設計することは容易ではない。
ただし、そのタイミングが異なったとしても比較対象のコンパイラが同等の参照解決能力を持っていることを示すことは不可能ではない。
その場合は、型検査と型推論も含む意味解析部分全体をまとめて比較対象とした上で、意味解析全体を経て最終的に同じように参照解決がなされていることを確認するという形になる。

\subsubsection{型検査・型推論}

SwiftはHaskellやMLなどの関数型言語と同様の非常に強力な型システムを備えており、その型検査と型推論はHindleyとMilnerによる型推論アルゴリズムを拡張したアルゴリズムによって行われている~\cite{swift-type-checker} ~\cite{tapl}。

HindleyとMilnerによる型推論アルゴリズム自体は非常によく知られている上に様々な言語で採用されているが、現行のSwiftコンパイラで行われている独自の拡張は他の型推論を用いる関数型言語と比較してSwiftに特徴的なパラダイムであるオブジェクト指向プログラミングや型パラメータ多相を実現するためのものである。

そのため、型検査と型推論についてコンパイラの比較を行う場合には、HindleyとMilnerによる型推論アルゴリズムを元にしたアルゴリズムを用いた設計にした上で、Swiftが独自に拡張している型についても同等の型推論・型検査能力を備えていることを示す必要がある。
ただし、参照解決の項で述べたように、特定の変数や関数の参照解決を行うために型推論が必要となる場合があるため、型検査や型推論と参照解決を分離して評価することは難しく、どちらかを比較する際には両方を同時に比較せざるを得ないという点には注意する必要がある。

\subsection{SIL生成}

SIL生成は、ASTを分析してより抽象度の低い独自中間言語であるSwift Intermediate Language(SIL)に変換することで最適化などの準備を行うためのステップである。
SILはLLVM-IRをベースとしてループやエラー処理、オブジェクト指向プログラミングのためのクラスの概念などを拡張し、プログラムの意味に基づく詳細なエラー検出などを行い易くした言語である ~\cite{sil}。

SIL生成のステップは特に一般的な手法などに基づいた処理が行われているわけではなく、完全にASTとSILの設計に依存した処理となる。
そのため、SIL生成部分を比較するためには比較するコンパイラにおけるASTの設計を現行のSwiftコンパイラと合わせる必要がある。
ただし実際には、ASTの構造はプログラミング言語の仕様と採用する構文解析手法に依存して決定するため、構文解析手法についても同一のものを選択する必要があるだろう。

\subsection{詳細解析}
\label{refinement:structure:analyze}

詳細解析は、SILを分析してASTのような抽象度の高い状態やLLVM-IRのような抽象度の低い状態では処理しづらい最適化やエラー検出を行うためのステップである。

現行のSwiftコンパイラではSILが包含するコールグラフやクラス階層といった情報を元に最適化やエラー検出を行っており、それらは手法ごとにモジュール化されている。
また、Swiftではメモリ管理の手法として各オブジェクトの作成が要求された際に自動的にメモリを割り当て、不要になったタイミングを検知してメモリを開放するAutomatic Reference Counting方式を用いており~\cite{arc}、そのための処理の挿入などもこの詳細解析で行っている。

詳細解析は複数のアルゴリズムの組み合わせによって構成されているため、比較するコンパイラでもそれぞれの処理について同一のアルゴリズムを採用することで同一の手法を使用した詳細解析を構築することが可能である。

\subsection{IR生成}

IR生成はSILを分析してLLVM-IRを生成することで、低抽象度での最適化や機械語生成を行うための準備を行うためのステップである。

LLVMは統一された中間言語であるLLVM-IRに対する最適化やLLVM-IRから様々なプラットフォーム上で動作可能な機械語へのコンパイルを行うツール群であり~\cite{llvm}、現行のコンパイラはこのLLVMを用いることでコンパイラのバックエンドをフロントエンドから完全に分離している。

LLVMのツールセットは実行可能なソフトウェアや用意されたAPIを通して使用されており、現行のコンパイラではC++で記述されたAPIを用いている。
このAPIには他の言語向けのものも存在するが、LLVMのツールは主にC++で記述されているためにC++のAPIが最も充実しており、現行のSwiftコンパイラはC++のAPIのみで実装されている高度なインターフェースを利用している。
そのため、C++以外の言語で実装されたSwiftコンパイラでは、現行のコンパイラと同じ手法で同じLLVM-IRを生成するように構成することは困難である。
