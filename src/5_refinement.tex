\chapter{Swiftコンパイラ中の可読性の比較が可能な箇所の絞り込み}
\label{refinement}

コンパイラは~\ref{side-effect:instance}節で見た事例だけからでも分かるように、同じプログラミング言語を対象としたものでもその設計手法やそもそも重視する問題が異なる場合がある。
かつ、~\ref{open-source:readability}節で挙げたように、ソフトウェアが対象とする問題やソフトウェアに使用される基幹的な手法はそのソフトウェアの複雑性を決定する上で大きな役割を演じる重要な変数となっている。
そのため、~\ref{readability:evaluation}節で述べたような手法を用いて実装を比較評価して得る複雑性の変化が確かにSelf-host化によって起こったものであると考えるためには、少なくとも対象とする問題と使用するプログラミング言語以外の基幹的な設計手法においては一致している必要がある。

そこで本章では、Swiftコンパイラを構成する各部分の目的と使用されている手法についてまとめ、どの部分ついて複雑性の比較が可能かを明らかにし、本研究で実装するSwiftコンパイラの設計要件を決定する土台を構築する。

\section{Swiftコンパイラの構成}
\label{refinement:structure}

Swiftコンパイラの大まかな構成を図~\ref{img:swift-compiler-process}に示した。
この図はSwiftの中心的開発者であるGroffとLattnerによるSwiftコンパイラについての説明資料~\cite{sil}中の図を訳し簡略化したものである。
Swiftコンパイラは図中矩形で表されている5つの処理によって図中円形で表されている4つのデータ形式を順に読み込み・生成する。
データ形式から処理を貫いて他のデータ形式まで伸びる矢線はデータ形式がどの処理によってどの順に生成されるかを表している。

\begin{figure}
    \begin{center}
        \includegraphics[scale=0.5]{./img/swift_compiler_process.png}
        \caption{Swiftコンパイラの構成}
        \label{img:swift-compiler-process}
    \end{center}
\end{figure}

この図が表現しているのは、Swiftコンパイラのデータ構造を媒介とした各処理ステップの独立性である。
Swiftコンパイラでは各処理ステップで扱うデータ形式を原則としてSwift、AST、SIL、LLVM-IRのいずれかに限定することで処理ステップ間の結合を疎にしている。

以下ではSwiftコンパイラで行われる各処理ステップについて、それぞれの目的とそのために使用されている手法について概説する。
なお、本論文内のSwiftコンパイラについての説明はswift-2.2-SNAPSHOT-2015-12-31-aのリリースにおけるソフトウェアの内容に基づいている。

\subsection{構文解析}

構文解析は次の2つの目的のために行われる。

\begin{enumerate}
    \item ただの文字列であるSwiftプログラムを解析して構造を持った抽象構文木(AST)に変換する
    \item プログラムの構文的な誤りを検知して報告する
\end{enumerate}

1つ目の目的を達成するために、SwiftではLL(k)クラスの再帰下降構文解析を用いている。
この手法についての理解を深めるために、以下では近代的なプログラミング言語に用いられるもう1つの構文解析手法と共にこの構文解析手法について解説する ~\cite{dragonbook}。

\subsubsection{下向き構文解析}

下向き構文解析では、プログラム全体を表現する非終端記号の文法から順により詳細な構成要素に深さ優先で分解していくことによってプログラムを解析する。
Swiftで用いられているLL(k)クラスの再帰下降構文解析は下向き構文解析の1種である。

% TODO dragonbook P.234のような図を追加

再帰下降構文解析は関数によって表現された手続きの集合として構成され、最初の文法を表現する手続きからより詳細な構成要素のための文法を表現する手続きを再帰的に呼び出すことで処理が行われる。
そのため、再帰下降構文解析では文法と実装が明確な対応関係を持っている事が多く、手作業で構文解析器を作成することが比較的簡単である。

\subsubsection{上向き構文解析}

上向き構文解析では、プログラムの字句を先頭から順に読み、具体的な字句をより抽象的な非終端記号へと還元していくことで当てはまる文法を決定していくことでプログラムを解析する。

% TODO dragonbook P.252のような図を追加

上向き構文解析において最もよく用いられているのはLR(1)クラスの構文解析器である。
LR(1)クラスの解析器は多くのプログラミング言語で用いられる文法の殆どを解析できる上、Yaccに代表されるような古くからよく用いられている構文解析器の自動生成するソフトウェアが存在する。

ただし、逆にLR(1)クラスの解析器を手作業で記述するのは容易ではない。

なお、LL(k)クラスの解析器についても構文解析器を自動生成するソフトウェアは存在するが、LR(1)クラスの解析器ほど頻繁に使用されてはいない ~\cite{antlr}。

\vspace{2em}

このように構文解析器には複数の設計手法が存在しており、その内の幾つかの手法においては同等の解析能力を保持しているため、どの手法を使用するかはプログラミング言語の仕様のみによっては決定しない。

また、構文解析器の2つ目の目的であるエラー検知については、その構文解析器が自動生成されるような場合には自動生成されたプログラムの用意するインターフェースによって検知タイミングや検知の難易度が変化する場合がある。

\subsection{意味解析}

意味解析の目的は次のとおりである。

\begin{enumerate}
    \item AST中の変数や関数、型を互いに結びつけ、プログラム全体の整合性を確認する
    \item 開発者によって省略されている情報を補足する
\end{enumerate}

1つ目の目的は主に参照解決と型検査、2つ目の目的は主に型推論を行うことによって達成される。
以下では意味解析の中で行われるこれら3つの処理についてSwiftで使用されている手法とその他のコンパイラで採用され得る手法について概説する。

\subsubsection{参照解決}

プログラム中で使用される変数や関数が正確にどこで宣言された変数や関数を指しているかを知ることができるタイミングはその変数や関数がどんな種類であるかに依存する。

例えば、プログラム~\ref{code:explicit-reference}のようなSwiftプログラムでは2行目で参照される変数xが直前の行で宣言されているため、構文解析を行いながら宣言された変数の情報を蓄積しておけば、最短で2行目のxを読んだ直後に変数xの参照を解決できる。
それに対してプログラム~\ref{code:implicit-reference}のように少し複雑化すると、例えばプログラム中5行目の変数s.xの参照を解決するためにはいくつかのステップを踏む必要が出てくる。
このプログラムで変数s.xの参照を解決するためには、まず変数sの参照を解決し、その型が明示されていないためにこれを推論し、クラスSampleのメンバリストから変数xの宣言を探し出すという長大なステップを踏まなければならない。

\begin{lstlisting}[caption=直ちに変数解決が可能である例, label=code:explicit-reference]
let x: Int = 1
print(x)
\end{lstlisting}

\begin{lstlisting}[caption=変数解決までに複数の処理が必要となる例, label=code:implicit-reference]
class Sample {
    let x: Int = 1
}
let s = Sample()
print(s.x)
\end{lstlisting}

このように、参照解決のタイミングはプログラミング言語の仕様によって制限されるが特に最短のタイミングで解決を行わないといけないということもないため、実装時の簡潔性などを勘案した上で各実装ごとに決定される。

事実現行のSwiftコンパイラでも参照解決のタイミングはその変数や関数の参照のされ方によってまちまちである。

\subsubsection{型検査・型推論}

SwiftはHaskellやMLなどの関数型言語と同様の非常に強力な型システムを備えており、その型検査と型推論はHindleyとMilnerによる型推論アルゴリズムを拡張したアルゴリズムによって行われている~\cite{swift-type-checker} ~\cite{tapl}。

HindleyとMilnerによる型推論アルゴリズム自体は非常によく知られている上に様々な言語で採用されているが、現行のSwiftコンパイラで行われている独自の拡張は他の型推論を用いる関数型言語と比較してSwiftに特徴的なパラダイムであるオブジェクト指向プログラミングや型パラメータ多相を実現するためのものである。

また、参照解決の項で述べたように、特定の変数や関数の参照解決を行うために型推論が必要となる場合があるため、型検査や型推論を行うタイミングも実装に依存する。


\subsection{SIL生成}

SIL生成は、ASTを分析してより抽象度の低い独自中間言語であるSwift Intermediate Language(SIL)に変換することで最適化などの準備を行うためのステップである。

SILは現行のSwift実装が用意する独自の中間表現であるため、SIL生成のステップでは特に一般的な手法などに基づいた処理が行われているわけではなく、完全にASTとSILの設計に依存した処理となる。

なお、SILはLLVM-IRをベースとしてループやエラー処理、オブジェクト指向プログラミングのためのクラスの概念などを拡張し、プログラムの意味に基づく詳細なエラー検出などを行い易くした言語である ~\cite{sil}。
SILの仕様は現行のSwiftコンパイラのソースコードと共に公開されているが、その設計自体がコンパイラの実装を想定したものとなっているため、必ずしも全てのSwiftコンパイラの実装でSILを用いることができるとは限らない。

\subsection{詳細解析}

詳細解析は、SILを分析してASTのような抽象度の高い状態やLLVM-IRのような抽象度の低い状態では処理しづらい最適化やエラー検出を行うためのステップである。

現行のSwiftコンパイラではSILが包含するコールグラフやクラス階層といった情報を元に最適化やエラー検出を行っており、それらは手法ごとにモジュール化されている。
また、Swiftではメモリ管理の手法として各オブジェクトの作成が要求された際に自動的にメモリを割り当て、不要になったタイミングを検知してメモリを開放するAutomatic Reference Counting方式を用いており~\cite{arc}、そのための処理の挿入などもこの詳細解析で行っている。

ただし、これらの処理は現行のSwiftコンパイラにおけるASTの設計やLLVM-IRの設計からこのステップで行うべきだと開発者によって判断されたためにそのタイミングで行われているに過ぎず、プログラミング言語の仕様などのすべての実装に共通した情報はそのタイミングの決定に殆ど影響を及ぼしてはいない。

\subsection{IR生成}

IR生成はSILを分析してLLVM-IRを生成することで、低抽象度での最適化や機械語生成を行うための準備を行うためのステップである。

LLVMは統一された中間言語であるLLVM-IRに対する最適化やLLVM-IRから様々なプラットフォーム上で動作可能な機械語へのコンパイルを行うツール群であり~\cite{llvm}、現行のコンパイラはこのLLVMを用いることでコンパイラのバックエンドをフロントエンドから完全に分離している。

LLVMのツールセットは実行可能なソフトウェアや用意されたAPIを通して使用されており、現行のコンパイラではC++で記述されたAPIを用いている。
このAPIには他の言語向けのものも存在するが、LLVMのツールは主にC++で記述されているためにC++のAPIが最も充実しており、現行のSwiftコンパイラはC++のAPIのみで実装されている高度なインターフェースを利用している。


\section{可読性の比較が可能な箇所}
\label{refinement:comperable}

~\ref{refinement:structure}節で見たとおり、SwiftコンパイラはLLVMのような外部のツールを用いたりSILのような独自言語を使用したりしているため、それらがTreeSwiftでもまったく同じように使用できるとは限らず、コンパイラ全体を比較対象とした場合は充分に同じ問題を同じ手法によって実装したものが比較できているとは言えなくなる可能性が高い。
しかし幸いなことに、Swiftコンパイラは各処理ステップごとに扱う問題とそこで使用されている手法が明確に分離されている。
そこで本節では、各処理ステップごとにTreeSwiftでも同じ問題と設計手法を用いることが可能かどうかを考察することによって可読性の比較箇所を絞り込み、有意義な比較評価を行うための下準備を行う。

* :open-source:readabilityで述べたように、扱う問題や手法が異なるとそのプログラムの複雑性は大きく変化する
* 参照解決や型推論、型検査を行う意味解析と最適化などを行う詳細解析は同じ問題を対象として同じ手段を取っているということを確認するのが難しい
* Self-host化し、Swiftで記述した場合はLLVMのC++ APIを直接使用できないため、C APIを使用することとなる
* IR生成部分は異なるAPIを使用することによる影響が大きく出ることが考えられる
* そのため、:readability:evaluationで上げたような手法で比較できそうなのは構文解析部分とSIL生成部分
* ただ、SIL生成部分はSILの仕様がまとまって公開される前だったため、設計に含めることが難しかった
* そのため、本研究では構文解析部分のみを設計対象とする
