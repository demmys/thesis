\appendix
\chapter{TreeSwiftの実装における留意点}

本研究で現行のSwiftコンパイラとの比較に用いたTreeSwiftは実際には本論文の動機として説明されているSwiftのオープンソース化よりもずっと以前から実装が進められていた。
つまりTreeSwiftはApple社の実装の詳細を知ること無くSwiftコンパイラを実装していたにも関わらず、結果的に構文解析器において同じ手法を採用していたということである。

本付録では、本論文の論旨とは一切関係ないものの、そうしたTreeSwiftの設計や実装を行う上で見つけた幾つかの気付きとそこから得た知見について、TreeSwiftの実装を説明しながら解説する。
本付録における情報は、本論文で提案しているようにSwiftコンパイラをSelf-host化する際はもちろん、Swiftを含む近代的な言語のコンパイラを設計する際などにも役立つと考えられる。


\section{SwiftでSwiftコンパイラを記述する上での障壁}

Apple社のSwiftコンパイラとTreeSwiftとの一番大きな差は実装開始当初から変わらず、Self-host化されているという点にある。
しかし、SwiftはもともとApple社の提供するフレームワークを用いた特定のプラットフォーム向けのアプリケーションを記述するためのドメイン特化言語のように発表されていた。
そのため、そもそもSwiftにはコンパイラを実装するために十分な機能が用意されていない可能性があり、まずはSwiftコンパイラの各ステップで行われている処理を明らかにして、それらの処理がSwift言語でも実現できるかどうかを考察する必要があった。

実際にそうした考察を行うと、Swiftコンパイラで行われている処理の中にはSwiftだけでは実現が困難な特に大きな2つの処理が存在していた。
本節ではそれらについて、その処理の実装が難しかった原因とTreeSwiftで取った解決方法について説明する。

\subsection{ファイル入出力}

まず、最初に問題となるのはファイルの入出力である。
コンパイラでは言わずもがな、プログラムのソースファイルを入力し、中間言語ファイルや場合によっては特定の形式のバイナリファイルなどを出力する必要がある。
また、ほとんどのコンパイラではソースファイルにエラーや警告が見つかった場合にその原因箇所をユーザに知らせることを目的として、字句や構文を表現する各オブジェクトにそのオブジェクトが対応するソースコード中の場所を保持させる。
その情報から実際のコードをスムーズに参照しエラーなどと一緒に表示するには、ファイル内の特定箇所に直接アクセスするインターフェースが必要となる。
しかし、これらの機能はSwiftの標準ライブラリでは提供されていないか不十分であった。

そのため、TreeSwiftではApple社がSwiftコンパイラと一緒に提供しているDarwinをベースとした環境のC言語の標準ライブラリをSwiftのライブラリであるかのように利用できるDarwinモジュールを用い、freadやfseekなどの関数をラッピングしたクラスを作ってファイルの入出力処理を行っている。

\subsection{LLVMの使用}

次に大きな問題となるのは、Swiftのバックエンドを担うLLVMの使用である。
もちろん、LLVMはコンパイラのバックエンドを実現するための1つの方法でしか無いので、TreeSwiftでもこれを採用しなければならないということはない。
しかし、Swiftの文法について詳細に見ると、その中にはLLVMを使用することが前提であるかのように感じるものがいくつかあることに気づく。
その典型的な例が、Swiftのアクセスレベル修飾子とLLVM-IRのリンケージタイプとの類似性である。

表~\ref{table:linkage-access-level}にSwiftの3つのアクセスレベル修飾子とLLVMの3つのリンケージタイプ~\cite{llvm-man}およびそれらの意味を似ている物同士で並べて示した。
SwiftにおけるファイルをLLVMにおけるモジュール、SwiftにおけるモジュールをLLVMにおけるオブジェクトファイルと読み替えれば、それぞれのアクセスレベル修飾子とリンケージタイプが明らかな対応関係にあることが分かる。
つまり、Swiftのアクセスレベル修飾子はLLVMをバックエンドに用いた際にその実装が簡単になるように設計されていると見れる。

\begin{table}[!hbtp]
    \begin{center}
        \caption{Swiftのアクセスレベル修飾子とLLVMのリンケージタイプの類似性}
        \begin{tabular}{|p{0.2\linewidth}|p{0.275\linewidth}||p{0.2\linewidth}|p{0.275\linewidth}|}
            \hline
            \multicolumn{2}{|c||}{Swiftのアクセスレベル修飾子} & \multicolumn{2}{|c|}{LLVMのリンケージタイプ}\\
            \hline
            名前 & 意味 & 名前 & 意味\\
            \hline
            \hline
            private & 修飾された要素は同一ファイル内からのみアクセス可能 & private & 修飾されたグローバル値は同一モジュール内からのみアクセス可能\\
            \hline
            internal & 修飾された要素は同一モジュール内からのみアクセス可能 & internal & 修飾されたグローバル値は同一オブジェクトファイル内からのみアクセス可能\\
            \hline
            public & 修飾された要素は外部モジュールからでもアクセス可能 & available\_externally& 修飾されたグローバル値はどこからでも参照可能\\
            \hline
        \end{tabular}
        \label{table:linkage-access-level}
    \end{center}
\end{table}

こうした類似点が他にも多数存在しているため、TreeSwiftにおいてもそのバックエンドにLLVM以外のプラットフォームを用いたり、バックエンドまで自作するような考え方はなかった。
ただそうすると、LLVMのメインとなるAPIがC++で提供されており、CやPython向けに提供されているAPIがその機能面においてC++のものよりも劣っているという点が問題になる。

TreeSwiftでは最初、この問題に対してLLVMのC++用APIをラップしたObjective-Cのライブラリを作成し、そのライブラリをSwiftから読み込むことで対処しようとした。
Objective-CにはC++と、SwiftにはObjective-Cとの相互運用性があるため、これらを組み合わせることで問題を克服できると考えていたからである。
しかし、実際にはObjective-Cのカプセル化機構ではバックグラウンドでC++のライブラリ内に定義されたC++のオブジェクトを用いながらも、それらを一切含まない純粋なObjective-Cだけのインターフェースを備えたラッパークラス群を定義することが難しく、そのコストの高さからこのアプローチは不採用に終わった。

結果として、現在のTreeSwiftではLLVMのC言語用APIを直接用いてSwiftからLLVMを使用している。
LLVMのC言語用APIにおいてSwiftコンパイラを設計する上で充分な機能が提供されているか、という点には未だ不安が残っているが、TreeSwiftの実装と同時期に作られたRuby言語に似たコンパイラ型言語であるCrystal~\cite{crystal}がBootstrapするためにこのAPIを使用しているという例もあるため、根本的な欠陥はないであろうと考え、実装に使用している。


\section{Swiftの文法と実装に対する示唆}

Swiftの文法はオープンソース化以前より公式ドキュメント~\cite{swift-grammar}上でBNFに近い形式の構文で公開されており、それを参照することでSwiftのユーザは文法の詳細までを知れるようになっている。
しかし、そこで公開されている文法は単にSwiftの文法を解説するためのドキュメントでしかなく、実装されている文法とは細部で異なる部分が多々存在している。
そのため、TreeSwiftを実装するにあたってはまずドキュメントの文法を全て書き写し、文法中の間違いや不適切な点を修正する作業を行う必要があった。

ただ、この修正作業のためにSwiftの文法を細かく確認したことで得られたSwiftの文法に関する知見は多く、結果としてそれらの知見が構文解析器を実装する上で重要な幾つかの判断を助けることとなった。
本節ではそうした知見の中から特にTreeSwiftの設計に影響を与えた1つの例について説明する。

\subsection{文法の曖昧性と構文解析器の文法クラス}

Swiftの基本的な文法はCやC++、Objective-Cなどの俗にC-Familyと呼ばれるプログラミング言語に類似しているが、それらの言語とは異なり、Swiftの文法はプログラマにコンパイラが構文解析を行うための記述を強いないように注意深く設計されている。
Swiftでは文の終わりを示す";"や制御構文の条件式の前後に"("と")"を付けることを強制しないし、順に実行される手続きの集まりは制御構文内・関数定義内・無名関数内などのどこに書かれるかにかかわらず、"\{"と"\}"で囲うことで表される。
しかし、こうしたプログラマ中心の設計は当然のことながら、他のC-Family言語のコンパイラでは問題になっていなかった箇所で構文の曖昧性を生み、コンパイラの仕事を増やしている。

例えば、プログラム~\ref{code:ambiguous}はSwiftの文法に則った全く正しいプログラムだが、このプログラムを曖昧性無く解析するのは非常に難しい。
2行目のifから始まる文を解析するためには、xの後に続く"\{"がxの引数のクロージャの始まりなのかif文の本体の始まりなのかを判断するために、xの参照を解決した上でその型を知る必要がある。
このプログラムにおいては直前にxの宣言があるためにxの参照を解決することはできるが、xの型は明示的に注釈されていないため、これを推論する必要が出てくる。

\begin{lstlisting}[caption=曖昧な構文を持った正しいSwiftプログラム, label=code:ambiguous]
let x = { (f: () -> Bool) in f() || true }
if x { print("closure argument") } {
    print("if body")
}
\end{lstlisting}

ではここで、制御構文の条件式の後に"\{"と"\}"で囲まれた手続きの集まりが2度以上現れるような曖昧性のある構文に当たった場合だけ、条件式の型推論を先に行うように構文解析器を設計したとする。
その設計を前提に考えると、今度はプログラム~\ref{code:complex-incorrect}のような複数のファイルにプログラムが分かれている多少複雑な例を解析する際に問題が生じる。
\begin{lstlisting}[caption=特定のアプローチではエラーの検出に多大な計算量を要する誤ったSwiftプログラム, label=code:complex-incorrect]
// class.swift
class Sample {
    let a = true
}

// function.swift
func f() {
    let s = Sample()
    if s.a {
        print("if body")
    } {
        print("missing else keyword body")
    }
}

// main.swift
f()
\end{lstlisting}

この例では2$\sim$4行目、7$\sim$14行目および17行目がそれぞれclass.swift、function.swift、main.swiftという3つのファイルに分かれているものとしているが、その11行目、function.swift内の5行目にif文に続くelse文に必要なキーワード"else"を書き忘れているというバグがある。
そのため、実際にプログラムの解析を始めると、このバグにより現在想定している構文解析器は9$\sim$13行目の文を曖昧性のある制御構文とみなし、s.aの型を推論しようと試みる。
しかし、この変数sのクラスSampleはclass.swiftという別ファイルで宣言されているため、そのクラスのインスタンス変数であるaの型を解決するためには、function.swiftよりもclass.swiftを先に解析しておく必要があり、ここで問題が生じる。
Swiftにおいてmain.swiftと命名されたファイル以外のファイルについて名前の規定はなく、それらの解析順を誘導することはできないからである。
つまり、現在想定している構文解析器においてこのプログラムから正しくエラーを検出するためには、曖昧性の原因となっている式とその式に関連するすべての項を正しく型付けできるか型付けできないことが明らかになるまで、main.swift以外の全ファイルを繰り返し解析し直す必要があるのだ。
この解決方法が解決したい問題に対して非常に複雑であり、かつ構文解析器の処理時間を必要以上に引き伸ばしてしまうことは明らかである。

そのため、こうしたSwiftの曖昧な構文では正確に解析することを諦め、曖昧性のある構文としてエラーにするか、どちらかの構文として決め打った解析のみを行うように構文解析器を設計する必要がある。
ただ、こうした設計を実現するためには、構文解析器で採用できる実装手法が限られてくる。

まず、先述のような曖昧性のある文法BNFなどで記述し、その構文解析器を完全に自動生成することは現実的ではない。
現在主に用いられている構文解析器の自動生成ソフトウェア~\cite{antlr}は解析対象の言語に曖昧な文法が含まれず、最悪の場合でもプログラム中の全ての字句を先読みすれば適用する文法が決定できるという前提のもとに設計されているからである。

さらに、たとえ一部であっても構文解析を手作業で書き下すとなると、~\ref{refinement:structure:parser}節でも述べたように、上向き構文解析を用いることは難しい。

そのため、近年のコンパイラで用いられているようなアルゴリズムを用いるのであれば、Swiftの構文解析器は下向きかつ任意個の字句を先読みするLL(k)などに代表される文法クラスのものとなり、かつそれを完全に手作業で書き下すか、一部のみについて自動生成を用いる形となる。

そうしたSwiftの文法の持つ性質から考えてTreeSwiftではLL(k)クラスの再帰下降構文解析を手作業によって書き下すこととなったので、Apple社のSwiftコンパイラにおいても全く同じアプローチの構文解析器が実装されていたという事実は驚くに値しないかもしれない。
しかし、Apple社の提供するドキュメントではSwiftの文法が下向き構文解析で解析不可能な左再帰を含んで記述されているところを見ると、文法の持つ性質を注視せずに構文解析器を設計し始めていた場合にはここで示したような問題と真正面からぶつかり、以上に非効率な構文解析器を実装してしまっていた危険性も十分にあったと考えられるのである。

% \subsection{変数の宣言とスコープ}
%
%
% \section{参照解決・型推論・メンバ呼び出しの相互依存性}
%
% 現時点のTreeSwiftにおいてまだうまく実装ができていないSwiftの機能として、意味解析のステップにおける相互に依存する参照・型・メンバ呼び出しの解決がある。
%
% ~\ref{refinement:structure:sema}節でも言及したように、Swiftではオブジェクト指向プログラミングを採用し、型の省略と関数のオーバーロードを同時に許しているため、特定の関数の参照を解決するためには適切な順で型推論やメンバ呼び出しの解決、関連する他の参照の解決を先に行う必要がある。
% さらに、その内の型推論だけに限って見てもSwiftはプロトコルと呼ばれる存在型やジェネリクスと呼ばれる全称型を利用できるようにしており、型同士の関係性を解決を行うプロセスまでもが非常に複雑化している。
%
% これは、他の言語と比較してもかなり欲張った設計である。
% よく使われている言語の例で言えば、C++やJava、Scalaは関数のオーバーロードを許すオブジェクト指向言語であるがSwiftのように強力な型推論を提供していないし、OCamlやRustといった関数型言語の色が強いオブジェクト指向言語では強力な型推論を提供している代わりに、完全な関数のオーバーロードを許してはいない。
% さらに比較して近年に開発された言語であっても、2005年に登場したHaxe~\cite{haxe-overload}や2011年に登場したばかりのCeylon~\cite{ceylon-overload}はOcamlなどと同様に強力な型推論と引き換えに関数のオーバーロードをその仕様に含めていない。
%
% そこで本節では、この意味解析の設計をSwiftコンパイラを実装する上で特に難易度の高い箇所であると捉え、TreeSwiftを実装する上で遭遇したこの意味解析における難題に繋がる2つの設計上の分岐点について解説する。
%
% \subsection{参照解決のタイミング}
%
% \subsection{メンバ呼び出しの型解決を行うタイミング}
