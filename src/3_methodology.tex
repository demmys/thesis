\chapter{可読性の差の評価方法}
\label{methodology}

本章では、Self-host化したSwiftコンパイラと現行のSwiftコンパイラとの間で可読性の差を評価する方法について述べる。


\section{可読性の比較に使用する指標}

本研究で実装したTreeSwiftは、~\ref{treeswift:test:result}節で示したとおり現行のSwiftコンパイラと同等の構文解析機能を保持しており、~\ref{treeswift:requirements}節で述べたとおりそれらの機能が同様の手法で実現されている。
そのため、TreeSwiftと現行のSwiftコンパイラにおいては構文解析器のソースコードの行数がより少ない方が、同じ意味を把握するために参照しなければならない行が少なく、より可読性が高いと考えることができる。

\section{比較対象}

比較に用いるコンパイラの要素としては構文解析器以外にも意味解析部分、コード生成部分、最適化部分が考えられるが、これらは次の理由により本研究の目的に見合った単純な比較ができないため対象としない。

まず、コード生成部分については現行のSwiftコンパイラとSwiftで記述するSwiftコンパイラの間で使用するLLVMのAPIが異なってしまう点で問題がある。
現行のSwiftコンパイラはC++で記述しているためにC++用のLLVM APIを使用するが、実装するコンパイラではSwiftにC++との相互運用性がないため、C用のLLVM APIを使用している。
これらのAPI間ではその設計が大きく異なり、その差によって結果に大きな影響が出てしまう可能性があるため、コード生成部分は比較の対象としない。

次に最適化部分については、その実装が言語の仕様によって制限されないという点に問題がある。
仕様に制限されないために各コンパイラでのサポート状況によって大きくその実装が異なってきてしまうため、比較の対象としない。

最後に、意味解析部分には主に型推論、型検査、型決定後の参照解決、詳細なエラー検出、言語レベルでの最適化などが含まれるが、このステップ中の各項目は密接に関わりあっており、コンパイラから切り出した際の単位が大きくなってしまうという問題がある。
評価する対象の単位が大きいと、その評価の結果は複数の機能間で相互に打ち消し合い、実際には各機能によっていい結果と悪い結果が混在しているにも関わらず、押し並べた結果のみが表出してしまう可能性がある。
そのため、意味解析部分についても比較の対象とはしない。

\section{比較するプログラムの同一性}

\section{本研究における可読性の差の検証方法}

各コンパイラのソースコードの内、ファイルを読み込み、字句解析および構文解析を行い、ASTを生成するまでに実行されるプログラムを記述した部分からエラー分を定義している箇所以外を抜き出し、その行数を計測・比較する。

%%% Local Variables:
%%% mode: japanese-latex
%%% TeX-master: "../thesis"
%%% End:
