\chapter{Self-host化したSwiftコンパイラ「TreeSwift」の設計と実装}
\label{implementation}

\section{可読性の比較が可能な箇所の絞り込み}
\label{implementation:comperable}

\subsection{Swiftコンパイラの構造}
\label{implementation:comperable:structure}

* Swiftコンパイラはおおまかに5つのステップに分けられる
    * 構文解析
    * 意味解析
    * SIL(Swift Intermediate Language)生成
    * 詳細解析
    * IR(LLVM-IR)生成

\subsection{可読性の比較が可能な箇所}
\label{implementation:comperable:part}

* :open-source:readabilityで述べたように、扱う問題や手法が異なるとそのプログラムの複雑性は大きく変化する
* 参照解決や型推論、型検査を行う意味解析と最適化などを行う詳細解析は同じ問題を対象として同じ手段を取っているということを確認するのが難しい
* Self-host化し、Swiftで記述した場合はLLVMのC++ APIを直接使用できないため、C APIを使用することとなる
* IR生成部分は異なるAPIを使用することによる影響が大きく出ることが考えられる
* そのため、:readability:evaluationで上げたような手法で比較できそうなのは構文解析部分とSIL生成部分
* ただ、SIL生成部分はSILの仕様がまとまって公開される前だったため、設計に含めることが難しかった
* そのため、本研究では構文解析部分のみを設計対象とする


\section{一般的なコンパイラの構文解析器の構造}
\label{implementation:parser}

:implementation:comperable:partでも言及したとおり、同じ問題を対象と出来ているかどうか、同じ手法を用いているかは比較の上で重要な注意点

\subsection{構文解析器の要素}

* 構文解析器は大きく分けて3つの機能からなる
    1. ソースファイルの文字列を意味のある文字単位(字句)に分ける字句解析
    2. 字句を意味のある文章単位ごとに処理してASTを組み上げる構文解析
    3. 構文の間違いを報告するエラー処理

\subsection{構文解析器の扱う問題}

* 大きく分けて2つの問題を解決するために構文解析器は存在する
    1. 構文処理
        * 正しい構文で記述されたソースコードを正しく解析すること
    2. エラー検知
        * 間違った構文で記述されたソースコードの間違いを指摘すること
* この2つの面の少なくとも大きな点については一致している状態で比較する必要がある

\subsection{構文解析器の手法}

* エラー検知については構文解析器だけでなく、後の意味解析や詳細解析でも行うため、実装によってどの段階でどのエラーを検知するか、などは大きく異なる場合がある
* 構文処理については文法に応じて3種類の手法がある (dragonbook)
    1. 汎用構文解析
    2. 下向き構文解析
    3. 上向き構文解析


\section{TreeSwiftの設計}

* 構文解析器のみに絞る
* 構文処理は網羅された仕様書が作成できるので、実際に解析ができるかどうかを網羅的に調べることができるので、できるだけ現行のものと同じになるように実装する
* エラー検知はどれだけ網羅できているかを判断しづらいため、比較の対象から外す
* 同じ手法を徹底することは難しいが、構文解析器全体では同じLL(k)方式を用いる


\section{実装の概要}

* 字句解析には各リテラルの解析を行う決定性有限オートマトンを複数用いている
* モジュール定義にはテキストファイルを使用する
* エラー回復は実装されていない



% \section{構文解析器が満たすべき特徴}
% \label{treeswift:requirements}
%
% Bootstrapを行う上でBootstrap後のコンパイラが満たすべき要件は、基本的にはその言語の仕様を満たしていることと、以前よりも性能が改善されていること以外にはない。
% しかし、本研究では現行のSwiftコンパイラと比較し考察することが目的であるため、評価を行うために必要な同一の特徴を保持している必要がある。
% 以下では、その特徴について述べる。
%
% \subsubsection{LL(k)方式の採用}
%
% 現行のコンパイラの構文解析器と同等の解析力とエラー検出力、拡張性を保持していることを保証するため、TreeSwiftでもLL(k)方式の構文解析器をSwiftで書き下すことによって実装を行う。
%
% \subsubsection{構文解析以外の部分の分離}
%
% 現行のコンパイラとの比較時に比較箇所が行う処理の差が出ないようにするため、型の推論や検査など構文解析以外の部分を構文解析器から分離する。
%
%
% \section{実装の概要}
%
% 本節では~\ref{treeswift:requirements}節で示した特徴を満たしながら、TreeSwiftがどのように実装されているかを説明する。
%
%
% \subsection{構文解析機能}
%
% ソースコードの構文を解析し、ASTにまとめ上げる処理は字句解析と構文解析の2つのステップに分けることができる。
%
% \subsubsection{字句解析}
%
% TreeSwiftでは図%~\ref{img:treeswift-lex} TODO
% のように、入力となるソースコードの文字を1字ずつ読みながら分類し、リテラルや識別子、予約語といった文字数の定まっていないトークンについてはそれぞれに専用の状態遷移機械によって生成する。
%
% \subsubsection{構文解析}
%
% 解析に使用する構文はApple社の提供するSwiftの公式ドキュメント~\cite{swift-grammar}にある構文をベースとするが、本資料は多くの誤りを含んでおりかつLL(k)形式では解析不可能な左再帰を含んでいるため、それらを修正した独自の構文定義を使用している。
%
% また、TreeSwiftでは~\ref{explain-swift:structure:parser}節で述べていたような現行のSwiftコンパイラが判断できていない構文についても、独自の構文定義の追加によって構文的に分類・区別している。
% そのため、TreeSwiftでは全ての構文について構文解析が完了した時点で曖昧性が排除されている。
%
%
% \subsection{参照解決機能}
%
% 変数や型などの参照を解決する機能の実現には、スコープを管理し、解決しなければならない。
% また、参照解決を行うタイミングもその言語仕様に合わせた選択が必要となる。
%
% \subsubsection{参照解決のタイミング}
%
% TreeSwiftでは~\ref{explain-swift:structure:parser}節で述べた現行のSwiftコンパイラの参照解決とは異なり、構文解析中には一切の参照解決を行わない。
% そのため、構文解析が完了して参照解決を行う際にはすでにすべての参照解決が可能であることが保証されており、参照解決を構文解析の本体から分離することが可能となっている。
%
% \subsubsection{スコープ解決}
%
% TreeSwiftにおけるスコープの解決は構文解析時にASTとは別に構築されるスコープツリーを用いて行う。
%
% スコープツリーでは分岐やループ、複合型の宣言などに伴って切り替わるスコープの入れ子構造を木として表現し、木の各ノードがそのスコープ内で宣言された変数や関数、型などをメンバとして保持する。
% また、木の各ノードは後の参照解決のためにスコープ内で参照された変数や関数、型などの情報も保持する。
%
% この構造により、参照解決時には木の各ノードを走査し、各参照情報についてその直近の親ノードから順に参照の対象がメンバとして含まれているかを遡って確認していけば、参照解決を行うことができるようになる。
%
% \subsubsection{曖昧な構文の解決}
%
% また、糖衣構文などを提供するために構文の曖昧性を残しているのもSwiftの特徴である。
% 例えば、プログラム~\ref{code:ambiguous}のような構文はSwiftの構文定義に則った全く正しいコードだが、一般的なアプローチでは正しく解析することができない。
% xの後に続く\{がxの引数のクロージャの始まりなのかif文の本体の始まりなのかは、xが引数としてクロージャを取る関数であることを解析機が知っていなければ決定できず、かつそのxはこれから解析を行う他のファイルなどに宣言されている可能性があるために、全てのファイルの解析を完了するまでxの参照を解決することはできない可能性があるためである。
%
% \begin{lstlisting}[caption=曖昧な構文を持った正しいSwiftコード, label=code:ambiguous]
% let x: (() -> ()) -> Bool = { f in true }
%
% if x { print("closure") } { print("if") }
% \end{lstlisting}
%
% こうした構文を一切の曖昧性なしに解析するためにはコンパイル対象となるプログラムを参照の解決に必要な回数だけ走査しなくてはならなくなるが、それは少なく見積もっても大変非効率であり、現実的ではない。
% 現状のSwiftコンパイラではこうした曖昧な構文は可能性のあるどちらかの構文に決め打ちして実装されており、もう一方を意図して記述しているプログラマに対しては全く見当はずれのエラーメッセージを提示することとなっている。
%
%
% \subsection{構文解析器のその他の機能}
%
% \subsubsection{エラーの処理}
%
% TreeSwiftの実行中に発見されたソースコードのエラーは構文解析ステップを通して同じ1つのインスタンスによって処理される。
% 構文解析器からはエラーを発見した時点でエラー文の参照と解析対象に関する情報をそのインスタンスに渡す。
% そのエラーが致命的なものであった場合や、エラーを管理するインスタンスに設定された既定値よりも多くのエラーが報告されていた場合は、その時点でSwiftのエラーハンドリング機能を用いて解析中の構文の関数を抜け、エラー表示などの処理を行う。
%
%
% \subsubsection{ライブラリの扱い}
%
% TreeSwiftでは独自のバイナリ形式を使用している現行のSwiftコンパイラとは異なり、標準ライブラリを含むライブラリ内に定義されている変数や関数、型などの情報を保持するモジュール情報ファイルをテキストファイルで管理している。
% それらのライブラリはimport文によって要求された時か、標準ライブラリの場合はプログラマがインプットした全てのソースコードの解析前に一度だけ解析され、一般的なソースコードと同様のASTを形成する。
%
% ただし、ライブラリのモジュール情報ファイルでは複数のファイルにまたがったグローバル変数などの定義は存在しないため、構文解析中に即座に参照解決を行う。
%
% \subsection{構文解析以外の実装}

%%% Local Variables:
%%% mode: japanese-latex
%%% TeX-master: "../bthesis"
%%% End:
