\chapter{序論}
\label{introduction}

\section{背景}
\label{introduction:background}

2015年12月、Apple社が予てより同社の提供するCocoaおよびCocoa Touchフレームワークを用いたソフトウェアの開発用として提供していたプログラミング言語Swiftをオープンソース化し、Linuxを中心としたさまざまなプラットフォームにおけるソフトウェアを開発するための拡張を開始した。
これによりプログラミング言語SwiftはObjective-Cの担ってきたiOSやMac OS Xなどにおけるソフトウェアの開発だけでなく、C++やJavaなど他の汎用プログラミング言語が担ってきたソフトウェア開発においてもそれらの代替となり得る可能性を持つこととなり、今後は今まで以上に様々な拡張と修正が行われるようになって行くことが予想される。
それに加え、オープンソースソフトウェアにおいては多くのプログラマが開発に関わるようになる都合から、拡張や修正のためのコードに対するレビューのプロセスがバグを事前に防ぐための手段としてより重要となる。

このような状況の変化によって、Swiftコンパイラにはこれまで強く求められていなかったある機能が求められるようになっている。
それは、Swiftコンパイラ自体のソースコードの可読性である。

プログラムに対する拡張や修正の効率は、そのプログラムの可読性に大きな影響を受けることがElshoffらによる~\cite{elshoff}などで知られており、コードレビューのようなプロセスではプログラムにおける実行速度などの性能の高さではなく、コードの読みやすさによってその効率が左右されることが明らかである。

これらのことから、これまではSwiftコンパイラについてよく知る極小数のメンバーによって開発が行われていたために顕著化していなかったが、今後Swiftコンパイラの可読性に対する要求が高まっていく可能性は高いと考えられる。

一方、Swift以外の汎用言語のコンパイラにおいてはそのソースコードの可読性を高めることを目的の内の1つとして、コンパイラをそのコンパイル対象の言語自体で開発するBootstrapを行っている例がよく見られる。
表~\ref{table:bootstrapping-languages}はWeb検索エンジンにおけるクエリヒット数からプログラミング言語の知名度を格付けしたTIOBE Index~\cite{tiobe}の2015年12月版において上げられている言語の内、汎用言語であるものだけを上位から20言語抽出し、それらの主要なコンパイラがその言語自体で記述されているかを示したものである。
この20言語の内だけでもBootstrapを行っているものが8言語あり、 その中に性能の問題からコンパイラ用の言語として採用されづらいインタプリタ型言語なども含まれていることを考慮すれば、かなりの言語がBootstrapされていることが分かる。

なお、SwiftにおけるBootstrapについて開発者のメーリングリスト~\cite{dev-ml}では、現在のSwiftにおいては未だ多くの機能が不足しているためにBootstrapについて考察するよりも他の問題を優先していること、Swiftコンパイラのバックエンドとして採用されているLLVMのAPIがC++で提供されており、そのSwiftへの移植が簡単ではないことから、SwiftのBootstrapについて議論を行うためにはもう少し時間が必要だという意見が上がっており、現状ではBootstrapを行うことに対して積極的ではない。

\begin{table}[hb]
    \begin{center}
        \caption{知名度の高いプログラミング言語のBootstrap状況}
        \begin{tabular}{|c|c|c|c|}
            \hline
            順位 & 言語名 & コンパイラ名 & Bootstrap状況 \\
            \hline
            1 & Java & javac & N (C, C++?) \\
            \hline
            1 & Java & OpenJDK & N (C++, Java) \\
            \hline
            2 & C & gcc & N (C++) \\
            \hline
            2 & C & clang & N (C++) \\
            \hline
            3 & C++ & gcc & Y \\
            \hline
            3 & C++ & clang & Y \\
            \hline
            3 & C++ & Microsoft Visual C++ & Y \\
            \hline
            4 & Python & CPython & N (C) \\
            \hline
            4 & Python & PyPy & Y \\
            \hline
            5 & C\# & Microsoft Visual C\# & N (C++) \\
            \hline
            5 & C\# & .NET Compiler Platform & Y \\
            \hline
            6 & PHP & Zend Engine & N (C) \\
            \hline
            7 & Visual Basic .NET & Visual Studio & N (C++, C\#) \\
            \hline
            7 & Visual Basic .NET & .NET Compiler Platform & Y \\
            \hline
            8 & JavaScript & SpiderMonkey & N (C, C++) \\
            \hline
            8 & JavaScript & V8 & N (C++, JavaScript) \\
            \hline
            9 & Perl & perl & N (C) \\
            \hline
            10 & Ruby & Ruby MRI & N (C) \\
            \hline
            12 & Visual Basic & Visual Studio & N (C++, C\#) \\
            \hline
            13 & Delphi/Object Pascal & Delphi & N (?) \\
            \hline
            13 & Delphi/Object Pascal & Free Pascal & Y \\
            \hline
            14 & Swift & swift & N (C++) \\
            \hline
            15 & Objective-C & clang & N (C++) \\
            \hline
            15 & Objective-C & gcc & N (C++) \\
            \hline
            17 & Pascal & Free Pascal & Y \\
            \hline
            17 & Pascal & GNU Pascal & N (C, Pascal) \\
            \hline
            20 & COBOL & GnuCOBOL & N (C, C++) \\
            \hline
            21 & Ada & GNAT & Y \\
            \hline
            22 & Fortran & GNU Fortran & N (C, C++) \\
            \hline
            22 & Fortran & Absoft Fortran Compiler & ? \\
            \hline
            23 & D & DMD & Y \\
            \hline
            24 & Groovy & groovy & N (Java, Groovy) \\
            \hline
        \end{tabular}
        \label{table:bootstrapping-languages}
    \end{center}
\end{table}


\section{本研究が着目する課題}
\label{introduction:issue}

本研究では、~\ref{introduction:background}節で述べたようにSwiftコンパイラの可読性に対する要求が高まっているという点に着目する。

現在のSwiftコンパイラにおけるコードの可読性は既存コードのコーディングスタイルへの追従やレビューの徹底などによって保たれているが、これはコミュニティベースで修正・追加されたコードがオープンソースとなる以前のコードの量を上回ったり、レビュアーが多様化することによって持続できなくなる。
また、これを持続するためにコーディング規約などの策定を行うことも考えられるが、詳細な規約はそれを把握するためだけでも多くの労力を要し、結果として可読性向上のための試みが当初の目的であったはずのプログラムの拡張や修正のコストを増大させてしまう可能性がある。


\section{本研究の目的とアプローチ}
\label{introduction:purpose}

本研究ではSwiftコンパイラの可読性を現在のものよりも向上させることを目的とする。
そのアプローチとして、Swiftで記述したSwiftコンパイラを実装し、その構文解析器におけるソースコードの行数を現行のSwiftコンパイラの構文解析器と比較することで、SwiftコンパイラのBootstrap化が有効であることを示す。

コンパイラのBootstrap化は一般的にそのコンパイラの対象言語が最初に記述された言語よりも必ず後発のものとなることから、各機能についてより高い水準となっている場合が多く、かつ一部の構文については言語仕様として定義されている各構文や機能を実際にその構文や機能を用いて定義し直すことができる。
Swiftにおいてもこのケースに当てはめることができることから、Bootstrapによって可読性を向上させられると考えられる。

さらにBootstrap化は~\ref{introduction:issue}節で述べた手法と比較して、そのコンパイラで使用するプログラミング言語を変更することによる可読性の向上であるために今後更に異なる言語で書き直されないかぎりはその効用が持続し、かつコーディング規約のような追加の制限を設けないので、その可読性の向上がより単純にプログラムの拡張や修正のコストを減少させると期待することができる。
また、Bootstrapを行うことによってBootstrap前は必要としていたC++の知識が不要となるため、C++に対して馴染みの浅い一部のプログラマにとっては拡張や修正のコストを減少させられるということも期待できる。

ただし、コンパイラのBootstrap化はコンパイラ全体に対して大きな変更を行うこととなるため、可読性の向上以外にも様々な影響を与える可能性が大いにあることには注意しておかなくてはならない。
本論文ではそうした副作用も含めたBootstrap化の現実的な優位性について議論できるよう、他の言語におけるBootstrapの事例から可読性とは別の影響についてまとめ、それらがSwiftのBootstrap化においてどのような働きをしうるかについても考察していく。

\subsection{本研究で評価の対象としない項目}

比較に用いるコンパイラの要素としては構文解析器以外にも意味解析部分、コード生成部分、最適化部分が考えられるが、これらは次の理由により本研究の目的に見合った単純な比較ができないため対象としない。

まず、コード生成部分については現行のSwiftコンパイラとSwiftで記述するSwiftコンパイラの間で使用するLLVMのAPIが異なってしまう点で問題がある。
現行のSwiftコンパイラはC++で記述しているためにC++用のLLVM APIを使用するが、実装するコンパイラではSwiftにC++との相互運用性がないため、C用のLLVM APIを使用している。
これらのAPI間ではその設計が大きく異なり、その差によって結果に大きな影響が出てしまう可能性があるため、コード生成部分は比較の対象としない。

次に最適化部分については、その実装が言語の仕様によって制限されないという点に問題がある。
仕様に制限されないために各コンパイラでのサポート状況によって大きくその実装が異なってきてしまうため、比較の対象としない。

最後に、意味解析部分には主に型推論、型検査、型決定後の参照解決、詳細なエラー検出、言語レベルでの最適化などが含まれるが、このステップ中の各項目は密接に関わりあっており、コンパイラから切り出した際の単位が大きくなってしまうという問題がある。
評価する対象の単位が大きいと、その評価の結果は複数の機能間で相互に打ち消し合い、実際には各機能によっていい結果と悪い結果が混在しているにも関わらず、押し並べた結果のみが表出してしまう可能性がある。
そのため、意味解析部分についても比較の対象とはしない。


\section{本論文の構成}

本論文の構成は次の通りである。

第2章では本研究の考察対象であるコンパイラのBootstrapについて、Swift以外の言語の事例から可読性の向上に対して有効であることを確認するとともにそれがコンパイラに与えうる他の影響についてもまとめ、それらの影響がSwiftのBootstrapにおいてどう作用しうるかを整理する。
第3章では本研究が着目するプログラミング言語Swiftの特徴とそのコンパイラ実装の基幹部分における特徴について説明する。
第4章では現行のSwiftコンパイラとの比較対象となるSwiftで記述したSwiftコンパイラ「TreeSwift」の構成について述べ、現行のSwiftコンパイラとの比較を行うために必要な要件を満たしていることを確認する。
第5章では現行のSwiftコンパイラとTreeSwiftの構文解析器についてそのソースコードの行数を比較し、その結果について考察する。
第6章では本研究の結論と今後の展望についてまとめる。

%%% Local Variables:
%%% mode: japanese-latex
%%% TeX-master: "../thesis"
%%% End:
