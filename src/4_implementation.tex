\chapter{TreeSwiftの設計と実装}
\label{treeswift}

本章では、~\ref{explain-swift}章で述べた現行のSwiftコンパイラの特徴から比較対象となるSwiftで記述したSwiftコンパイラTreeSwiftの構文解析器が満たすべき特徴を整理し、それがどのように実装されているかについて述べる。

\section{構文解析器が満たすべき特徴}
\label{treeswift:requirements}

Bootstrapを行う上でBootstrap後のコンパイラが満たすべき要件は、基本的にはその言語の仕様を満たしていることと、以前よりも性能が改善されていること以外にはない。
しかし、本研究では現行のSwiftコンパイラと比較し考察することが目的であるため、評価を行うために必要な同一の特徴を保持している必要がある。
以下では、その特徴について述べる。

\subsubsection{LL(k)方式の採用}

現行のコンパイラの構文解析器と同等の解析力とエラー検出力、拡張性を保持していることを保証するため、TreeSwiftでもLL(k)方式の構文解析器をSwiftで書き下すことによって実装を行う。

\subsubsection{エラー文の分離}

エラー文の書き方によるソースコードの分量の変化を防ぐため、エラー文自体は構文解析器自体と別のファイルに定義し、それを参照する形を取る。

\subsubsection{構文解析以外の部分の分離}

現行のコンパイラとの比較時に比較箇所が行う処理の差が出ないようにするため、型の推論や検査など構文解析以外の部分を構文解析器から分離する。


\section{実装の概要}

本節では~\ref{treeswift:requirements}節で示した特徴を満たしながら、TreeSwiftがどのように実装されているかを説明する。


\subsection{構文解析機能}

ソースコードの構文を解析し、ASTにまとめ上げる処理は字句解析と構文解析の2つのステップに分けることができる。

\subsubsection{字句解析}

TreeSwiftでは図%~\ref{img:treeswift-lex} TODO
のように、入力となるソースコードの文字を1字ずつ読みながら分類し、リテラルや識別子、予約語といった文字数の定まっていないトークンについてはそれぞれに専用の状態遷移機械によって生成する。

\subsubsection{構文解析}

解析に使用する構文はApple社の提供するSwiftの公式ドキュメント~\cite{swift-grammar}にある構文をベースとするが、本資料は多くの誤りを含んでおりかつLL(k)形式では解析不可能な左再帰を含んでいるため、それらを修正した独自の構文定義を使用している。

また、TreeSwiftでは~\ref{explain-swift:structure:parser}節で述べていたような現行のSwiftコンパイラが判断できていない構文についても、独自の構文定義の追加によって構文的に分類・区別している。
そのため、TreeSwiftでは全ての構文について構文解析が完了した時点で曖昧性が排除されている。


\subsection{参照解決機能}

変数や型などの参照を解決する機能の実現には、スコープを管理し、解決しなければならない。
また、参照解決を行うタイミングもその言語仕様に合わせた選択が必要となる。

\subsubsection{参照解決のタイミング}

TreeSwiftでは~\ref{explain-swift:structure:parser}節で述べた現行のSwiftコンパイラの参照解決とは異なり、構文解析中には一切の参照解決を行わない。
そのため、構文解析が完了して参照解決を行う際にはすでにすべての参照解決が可能であることが保証されており、参照解決を構文解析の本体から分離することが可能となっている。

\subsubsection{スコープ解決}

TreeSwiftにおけるスコープの解決は構文解析時にASTとは別に構築されるスコープツリーを用いて行う。

スコープツリーでは分岐やループ、複合型の宣言などに伴って切り替わるスコープの入れ子構造を木として表現し、木の各ノードがそのスコープ内で宣言された変数や関数、型などをメンバとして保持する。
また、木の各ノードは後の参照解決のためにスコープ内で参照された変数や関数、型などの情報も保持する。

この構造により、参照解決時には木の各ノードを走査し、各参照情報についてその直近の親ノードから順に参照の対象がメンバとして含まれているかを遡って確認していけば、参照解決を行うことができるようになる。


\subsection{構文解析器のその他の機能}

\subsubsection{エラーの処理}

TreeSwiftの実行中に発見されたソースコードのエラーは構文解析ステップを通して同じ1つのインスタンスによって処理される。
構文解析器からはエラーを発見した時点でエラー文の参照と解析対象に関する情報をそのインスタンスに渡す。
そのエラーが致命的なものであった場合や、エラーを管理するインスタンスに設定された既定値よりも多くのエラーが報告されていた場合は、その時点でSwiftのエラーハンドリング機能を用いて解析中の構文の関数を抜け、エラー表示などの処理を行う。


\subsubsection{ライブラリの扱い}

TreeSwiftでは独自のバイナリ形式を使用している現行のSwiftコンパイラとは異なり、標準ライブラリを含むライブラリ内に定義されている変数や関数、型などの情報を保持するモジュール情報ファイルをテキストファイルで管理している。
それらのライブラリはimport文によって要求された時か、標準ライブラリの場合はプログラマがインプットした全てのソースコードの解析前に一度だけ解析され、一般的なソースコードと同様のASTを形成する。

ただし、ライブラリのモジュール情報ファイルでは複数のファイルにまたがったグローバル変数などの定義は存在しないため、構文解析中に即座に参照解決を行う。


\subsection{構文解析以外の実装}


\section{解析可能な構文の検証}

本節では、TreeSwiftを用いて実際に構文の解析を行った結果によってTreeSwiftが十分な構文解析機能を持っていることを示す。

\subsection{検証するプログラム}

\subsection{検証の結果}

\subsection{検証のまとめ}

%%% Local Variables:
%%% mode: japanese-latex
%%% TeX-master: "../bthesis"
%%% End:
